[{"title":"Java核心技术卷","path":"/2025/04/07/Java核心技术卷/","content":"第1章 Java程序设计概述1.1 Java程序设计平台1.2 Java白皮书的关键术语1.2.1 简单性1.2.2 面向对象1.2.3 分布式1.2.4 健壮性1.2.5 安全性1.2.6 体系结构中立1.2.7 可移植性1.2.8 解释性1.2.9 高性能1.2.10 多线程1.2.11 动态性1.3 Java applet与Internet1.4 Java发展简史1.5 关于Java的常见误解第2章 Java编程环境2.1 安装Java开发工具包2.1.1 下载JDK2.1.2 设置JDK2.1.3 安装源文件和文档2.2 使用命令行工具2.3 使用集成开发环境2.4 JShell第3章 Java的基本程序设计结构3.1 一个简单的Java程序3.2 注释3.3 数据类型3.3.1 整型3.3.2 浮点类型3.3.3 char类型3.3.4 Unicode和char类型3.3.5 boolean类型3.4 变量与常量3.4.1 声明变量3.4.2 初始化变量3.4.3 常量3.4.4 枚举类型3.5 运算符3.5.1 算术运算符3.5.2 数学函数与常量3.5.3 数值类型之间的转换3.5.4 强制类型转换3.5.5 赋值3.5.6 自增与自减运算符3.5.7 关系和boolean运算符3.5.8 条件运算符3.5.9 switch表达式3.5.10 位运算符3.5.11 括号与运算符级别3.6 字符串3.6.1 子串3.6.2 拼接3.6.3 字符串不可变3.6.4 检测字符串是否相等3.6.5 空串与Null串3.6.6 码点与代码单元3.6.7 String API3.6.8 阅读联机API文档3.6.9 构建字符串3.6.10 文本块3.7 输入与输出3.7.1 读取输入3.7.2 格式化输出3.7.3 文件输入与输出3.8 控制流程3.8.1 块作用域3.8.2 条件语句3.8.3 循环3.8.4 确定性循环3.8.5 多重选择：switch语句3.8.6 中断控制流程的语句3.9 大数3.10 数组3.10.1 声明数组3.10.2 访问数组元素3.10.3 for each循环3.10.4 数组拷贝3.10.5 命令行参数3.10.6 数组排序3.10.7 多维数组3.10.8 不规则数组第4章 对象与类4.1 面向对象程序设计概述4.1.1 类4.1.2 对象4.1.3 识别类4.1.4 类之间的关系4.2 使用预定义类4.2.1 对象与对象变量4.2.2 Java类库中的LocalDate类4.2.3 更改器方法与访问器方法4.3 自定义类4.3.1 Employee类4.3.2 使用多个源文件4.3.3 剖析Employee类4.3.4 从构造器开始4.3.5 用var声明局部变量4.3.6 使用null引用4.3.7 隐式参数与显式参数4.3.8 封装的优点4.3.9 基于类的访问权限4.3.10 私有方法4.3.11 final实例字段4.4 静态字段与静态方法4.4.1 静态字段4.4.2 静态常量4.4.3 静态方法4.4.4 工厂方法4.4.5 main方法4.5 方法参数4.6 对象构造4.6.1 重载4.6.2 默认字段初始化4.6.3 无参数的构造器4.6.4 显式字段初始化4.6.5 参数名4.6.6 调用另一个构造器4.6.7 初始化块4.6.8 对象析构与finalize方法4.7 记录4.7.1 记录概念4.7.2 构造器：标准、自定义和简洁4.8 包4.8.1 包名4.8.2 类的导入4.8.3 静态导入4.8.4 在包中增加类4.8.5 包访问4.8.6 类路径4.8.7 设置类路径4.9 JAR文件4.9.1 创建JAR文件4.9.2 清单文件4.9.3 可执行JAR文件4.9.4 多版本JAR文件4.9.5 关于命令行选项的说明4.10 文档注释4.10.1 注释的插入4.10.2 类注释4.10.3 方法注释4.10.4 字段注释4.10.5 通用注释4.10.6 包注释4.10.7 注释提取4.11 类设计技巧第5章 继承5.1 类、超类和子类5.1.1 定义子类5.1.2 覆盖方法5.1.3 子类构造器5.1.4 继承层次结构5.1.5 多态5.1.6 理解方法调用5.1.7 阻止继承：final类和方法5.1.8 强制类型转换5.1.9 instanceof模式匹配5.1.10 受保护访问5.2 Object：所有类的超类5.2.1 Object类型的变量5.2.2 equals方法5.2.3 相等测试与继承5.2.4 hashCode方法5.2.5 toString方法5.3 泛型数组列表5.3.1 声明数组列表第8章 泛型程序设计8.6 泛型代码和虚拟机8.6.3 不能创建参数化类型的数组8.6.4 Varargs警告8.6.5 不能实例化类型变量őle 8.6.6 不能构造泛型数组8.6.7 泛型类的静态上下文中类型变量无效8.6.8 不能抛出或捕获泛型类的实例8.6.9 可以取消对检查型异常的检查8.6.10 注意擦除后的冲突8.7 泛型类型的继承规则8.8 通配符类型8.8.1 通配符概念8.8.2 通配符的超类型限定8.8.3 无限定通配符8.8.4 通配符捕获8.9 反射和泛型8.9.1 泛型Class类8.9.2 使用Class＜T＞参数进行类型匹配8.9.3 虚拟机中的泛型类型信息8.9.4 类型字面量第9章 集合9.1 Java集合框架9.1.1 集合接口与实现分离9.1.2 Collection接口9.1.3 迭代器9.1.4 泛型实用方法9.2 集合框架中的接口9.3 具体集合9.3.1 链表9.3.2 数组列表9.3.3 散列集9.3.4 树集9.3.5 队列与双端队列9.3.6 优先队列9.4 映射9.4.1 基本映射操作9.4.2 更新映射条目9.4.3 映射视图9.4.4 弱散列映射9.4.5 链接散列集与映射9.4.6 枚举集与映射9.4.7 标识散列映射9.5 副本与视图9.5.1 小集合9.5.2 不可修改的副本和视图9.5.3 子范围9.5.4 检查型视图9.5.5 同步视图9.5.6 关于可选操作的说明9.6 算法9.6.1 为什么使用泛型算法9.6.2 排序与混排9.6.3 二分查找9.6.4 简单算法9.6.5 批操作9.6.6 集合与数组的转换9.6.7 编写自己的算法9.7 遗留的集合9.7.1 Hashtable类9.7.2 枚举9.7.3 属性映射9.7.4 栈9.7.5 位集第10章 图形用户界面程序设计10.1 Java用户界面工具包简史10.2 显示窗体10.2.1 创建窗体10.2.2 窗体属性10.3 在组件中显示信息10.3.1 处理2D图形10.3.2 使用颜色10.3.3 使用字体10.3.4 显示图像10.4 事件处理10.4.1 基本事件处理概念10.4.2 实例：处理按钮点击事件10.4.3 简洁地指定监听器10.4.4 适配器类10.4.5 动作10.4.6 鼠标事件10.4.7 AWT事件继承层次结构10.5 首选项API第11章 Swing用户界面组件11.1 Swing和模型－视图－控制器设计模式11.2 布局管理概述11.2.1 布局管理器11.2.2 边框布局11.2.3 网格布局11.3 文本输入11.3.1 文本域11.3.2 标签和标签组件11.3.3 密码域11.3.4 文本区11.3.5 滚动窗格11.4 选择组件11.4.1 复选框11.4.2 单选按钮11.4.3 边框11.4.4 组合框11.4.5 滑动条11.5 菜单11.5.1 菜单构建11.5.2 菜单项中的图标11.5.3 复选框和单选按钮菜单项11.5.4 弹出菜单11.5.5 键盘助记符和加速器11.5.6 启用和禁用菜单项11.5.7 工具栏11.5.8 工具提示11.6 复杂的布局管理11.6.1 网格包布局11.6.2 定制布局管理器11.7 对话框11.7.1 选项对话框11.7.2 创建对话框11.7.3 数据交换11.7.4 文件对话框第12章 并发12.1 什么是线程12.2 线程状态12.2.1 新建线程12.2.2 可运行线程12.2.3 阻塞和等待线程12.2.4 终止线程12.3 线程属性12.3.1 中断线程12.3.2 守护线程12.3.3 线程名12.3.4 未捕获异常的处理器12.3.5 线程优先级12.4 同步12.4.1 竞态条件的一个例子12.4.2 竞态条件详解12.4.3 锁对象12.4.4 条件对象12.4.5 synchronized关键字12.4.6 同步块12.4.7 监视器概念12.4.8 volatile字段12.4.9 final变量12.4.10 原子性12.4.11 死锁12.4.12 为什么废弃stop和suspend方法12.4.13 按需初始化12.4.14 线程局部变量12.5 线程安全的集合12.5.1 阻塞队列12.5.2 高效的映射、集和队列12.5.3 映射条目的原子更新12.5.4 并发散列映射的批操作12.5.5 并发集视图12.5.6 写时拷贝数组12.5.7 并行数组算法12.5.8 较早的线程安全集合12.6 任务和线程池12.6.1 Callable与Future12.6.2 执行器12.6.3 控制任务组12.6.4 fork-join框架12.7 异步计算12.7.1 可完成Future12.7.2 组合可完成Future12.7.3 用户界面回调中的长时间运行任务12.8 进程12.8.1 建立进程12.8.2 运行进程12.8.3 进程句柄附录 Java关键字"},{"title":"吉他谱","path":"/2025/03/12/吉他谱/","content":"周杰伦花海 蒲公英的约定 晴天 安静 说好的幸福呢 借口 七里香 回到过去 一路向北 邓紫棋唯一 林俊杰她说 可惜没如果 孙燕姿我怀念的 薛之谦演员 方圆几里 绅士 其实 像风一样"},{"title":"老姚吉他从零起步基础教学","path":"/2025/03/12/老姚吉他从零起步基础教学/","content":"第一课 第二课 第三课 第四课 第五课 第六课 第七课 第八课 第九课 第十课 第十一课 第十二课 第十三课 第十四课 第十五课 第十六课 第十七课 第十八课 第十九课 第二十课 第二十一课 第二十二课 第二十三课 第二十四课 第二十五课 第二十六课 第二十七课第二十八课 第二十九课 第三十课 第三十一课第三十二课第三十三课第三十四课第三十五课第三十六课第三十七课第三十八课第三十九课第四十课第四十一课第四十二课第四十三课第四十四课第四十五课第四十六课第四十七课第四十八课第四十九课第五十课第五十一课第五十二课第五十三课第五十四课第五十五课第五十六课第五十七课第五十八课第五十九课第六十课第六十一课第六十二课第六十三课第六十四课第六十五课第六十六课第六十七课第六十八课第六十九课第七十课第七十一课第七十二课第七十三课第七十四课第七十五课第七十六课第七十七课第七十八课第七十九课第八十课第八十一课第八十二课第八十三课第八十四课第八十五课第八十六课第八十七课第八十八课第八十九课第九十课第九十一课第九十二课第九十三课第九十四课第九十五课第九十六课第九十七课第九十八课第九十九课第一百课"},{"title":"第一行代码","path":"/2024/12/28/第一行代码/","content":"5.4 动态加载布局的技巧表5.1 Android 中常见的限定符"},{"title":"Android编程权威指南","path":"/2024/12/17/Android编程权威指南/","content":"第 1 章Android开发初体验1.1 Android开发基础1.2 创建Android项目1.3 Android Studio使用导航1.4 用户界面设计按照约定，布局文件的命名基于其关联的activity：activity_作为前缀，activity子类名的其余部分全部转小写并紧随其后，单词之间以 下划线隔开。例如，当前新建项目的布局文件名为 activity_main.xml，或者说你有个activity名为 SplashScreenActivity，那么对应的布局就命名为 activity_splash_screen。 1.4.1 视图层级结构部件包含在视图对象的层级结构中，这种结构又称作视图层级结构 （view hierarchy）。 1.4.2 部件属性 match_parent：视图与其父视图大小相同。 wrap_content：视图将根据其显示内容自动调整大小。 orientation：它决定子部件是水平放置还是垂直放置。 text：该属性指定部件要显示的文字内容。 1.4.3 创建字符串资源1.4.4 预览布局旋转设备会改变设备配置 （device configuration）。设备配置实际 是一系列特征组合，用来描述设备当前状态。这些特征包括：屏幕方向、屏幕像素密度、屏幕尺寸、键盘类型、底座模式以及语言等。"},{"title":"Kotlin编程权威指南","path":"/2024/12/12/Kotlin编程权威指南/","content":"第1章　Kotlin应用开发初体验1.1　安装IntelliJ IDEA1.2　第一个Kotlin项目1.2.1　创建首个Kotlin文件1.2.2　运行Kotlin文件1.3　Kotlin REPL1.4　深入学习：为什么要用IntelliJ1.5　深入学习：面向JVM1.6　挑战练习：使用REPL研究Kotlin中的算数运算符第2章　变量、常量和类型2.1　数据类型2.2　声明变量2.3　Kotlin的内置数据类型2.4　只读变量2.5　类型推断2.6　编译时常量2.7　查看Kotlin字节码连按Shift键两次，打开Search Everywhere对话框。如图2-9所示， 在搜索框中输入show kotlin，然后选择结果列表中的Show Kotlin Bytecode选项。（也可以经由Tools → Kotlin → Show Kotlin Bytecode 菜单项打开字节码工具窗口。） 2.8　深入学习：Kotlin中的Java基本数据类型2.9　挑战练习：定义hasSteed变量2.10　挑战练习：独角兽之角2.11　挑战练习：魔镜第3章　条件语句3.1　if&#x2F;else语句3.1.1　添加更多条件3.1.2　if&#x2F;else嵌套语句3.1.3　更优雅的条件语句3.2　range3.3　when表达式3.4　string模板3.5　挑战练习：range研究3.6　挑战练习：优化玩家光环展示3.7　挑战练习：可配置的玩家状况报告格式第4章　函数4.1　使用函数重构代码4.2　函数结构剖析4.2.1　函数头4.2.2　函数体4.2.3　函数作用域4.3　调用函数4.4　以函数重构代码4.5　自定义函数4.6　默认值参4.7　单表达式函数4.8　Unit函数4.9　具名函数参数4.10　深入学习：Nothing类型4.11　深入学习：Java中的文件级函数4.12　深入学习：函数重载4.13　深入学习：反引号中的函数名4.14　挑战练习：单表达式函数4.15　挑战练习：Fireball醉酒程度4.16　挑战练习：醉酒状态报告第5章　匿名函数与函数类型5.1　匿名函数5.1.1　函数类型5.1.2　隐式返回5.1.3　函数参数5.1.4　it关键字5.1.5　多个参数5.2　类型推断5.3　定义参数是函数的函数简略语法5.4　函数内联5.5　函数引用5.6　函数类型作为返回类型5.7　深入学习：Kotlin中的lambda就是闭包5.8　深入学习：lambda与匿名内部类第6章　null安全与异常6.1　可空性6.2　Kotlin的null类型6.3　编译时间与运行时间6.4　null安全6.4.1　选项一：安全调用操作符6.4.2　选项二：使用!!.操作符6.4.3　选项三：使用if判断null值情况6.5　异常6.5.1　抛出异常6.5.2　自定义异常6.5.3　处理异常6.6　先决条件函数6.7　null：真的一无是处吗6.8　深入学习：已检查异常与未检查异常6.9　深入学习：可空性该如何保证第7章　字符串7.1　字符串截取7.1.1　substring7.1.2　split7.2　字符串操作不可变字符串7.3　字符串比较7.4　深入学习：Unicode7.5　深入学习：遍历字符7.6　挑战练习：改进toDragonSpeak函数第8章　数8.1　数字类型8.2　整数8.3　小数数字8.4　字符串转数值类型8.5　Int类型转Double类型8.6　Double类型格式化8.7　Double类型转换为Int类型8.8　深入学习：位运算8.9　挑战练习：还剩多少酒8.10　挑战练习：解决负数余额问题8.11　挑战练习：龙币第9章　标准库函数9.1　apply9.2　let9.3　run9.4　with9.5　also9.6　takeIf9.7　使用标准库函数第10章　List与Set10.1　List10.1.1　获取列表元素10.1.2　更改列表内容10.2　遍历10.3　将文件数据读取到列表10.4　解构10.5　Set10.5.1　创建一个Set集合10.5.2　向Set集合中添加元素10.6　while循环10.7　break表达式10.8　集合转换10.9　深入学习：数组类型10.10　深入学习：只读与不可变10.11　挑战练习：美化酒水单10.12　挑战练习：进一步美化酒水单第11章　Map11.1　创建一个Map11.2　读取Map集合的值11.3　向Map集合添加项11.4　修改Map集合值11.5　挑战练习：守卫小客栈第12章　定义类12.1　定义一个类12.2　构造实例12.3　类函数12.4　可见性与封装12.5　类属性12.5.1　属性getter与setter12.5.2　属性可见性12.5.3　计算属性12.6　重构NyetHack12.7　使用包12.8　深入学习：细看var与val属性12.9　深入学习：防范竞态条件12.10　深入学习：私有包第13章　初始化13.1　构造函数13.1.1　主构造函数13.1.2　在主构造函数里定义属性13.1.3　次构造函数13.1.4　默认参数13.1.5　命名参数13.2　初始化块13.3　属性初始化13.4　初始化顺序13.5　延迟初始化13.5.1　延迟初始化13.5.2　惰性初始化13.6　深入学习：初始化陷阱13.7　挑战练习：圣剑之谜第14章　继承14.1　定义Room类14.2　创建子类14.3　类型检测14.4　Kotlin类层次14.4.1　类型转换14.4.2　智能类型转换14.5　深入学习：Any第15章　对象15.1　object关键字15.1.1　对象声明15.1.2　对象表达式15.1.3　伴生对象15.2　嵌套类15.3　数据类15.3.1　toString15.3.2　equals15.3.3　copy15.3.4　解构声明15.4　枚举类15.5　运算符重载15.6　探索NyetHack游戏世界15.7　深入学习：定义结构比较15.8　深入学习：代数数据类型15.9　挑战练习：“quit”命令15.10　挑战练习：魔力地图15.11　挑战练习：摇铃第16章　接口与抽象类16.1　定义接口16.2　实现接口16.3　默认实现16.4　抽象类16.5　在NyetHack游戏里打怪第17章　泛型17.1　定义泛型类17.2　泛型函数17.3　多泛型参数17.4　泛型约束17.5　vararg关键字与get函数17.6　in与out17.7　深入学习：reified关键字第18章　扩展18.1　定义扩展函数在超类上定义扩展函数18.2　泛型扩展函数18.3　扩展属性18.4　可空类扩展18.5　扩展实现揭秘18.6　用扩展封装代码18.7　定义扩展文件18.8　重命名扩展18.9　Kotlin标准库中的扩展18.10　深入学习：带接收者的函数字面量18.11　挑战练习：toDragonSpeak扩展18.12　挑战练习：frame扩展第19章　函数式编程基础19.1　函数类别19.1.1　变换19.1.2　过滤19.1.3　合并19.2　为什么要学习函数式编程19.3　序列19.4　深入学习：评估代码性能19.5　深入学习：Arrow.kt19.6　挑战练习：Map值反转19.7　挑战练习：应用函数式编程19.8　挑战练习：滑窗算法第20章　Kotlin与Java互操作20.1　与Java类互操作20.2　互操作性与可空性20.3　类型映射20.4　getter和setter方法与互操作性20.5　类之外20.6　异常与互操作性20.7　Java中的函数类型第21章　用Kotlin开发首个Android应用21.1　Android Studio21.1.1　Gradle配置21.1.2　项目组织21.2　定义UI21.3　用模拟器运行应用21.4　生成角色21.5　Activity类21.6　实例化视图21.7　Kotlin Android扩展21.8　设置单击事件监听器21.9　保存实例状态读取保存的实例状态21.10　使用扩展重构代码21.11　深入学习：Android KTX与Anko库第22章　Kotlin协程简介22.1　解析角色数据22.2　获取动态数据22.3　Android主线程22.4　启用协程22.5　使用async指定协程22.6　launch与async&#x2F;await22.7　挂起函数22.8　挑战练习：动态数据22.9　挑战练习：最小力量值第23章　编后语23.1　前方的路23.2　插个广告23.3　致谢附录A　补充挑战练习术语表连接图灵看完了"},{"title":"CAN协议","path":"/2024/12/05/can-protocol/","content":"Legend - CAN 参数说明 - CAN Property 属性 Description 描述 Msg Name 报文名称 Message name 报文名称 Msg Type 报文类型 Msg Type: Normal, NM, Diag 报文类型：常规应用报文，网络管理报文，诊断报文 Msg ID 报文标识符 Message identifier 报文标识符 Msg Send Type 报文发送类型 Send type for the message. 报文的发送类型 Send type:”Cycle”, “Event”, “IfActive”, “CE” and “CA” 发送类型：”Cycle”, “Event”, “IfActive”, “CE” and “CA” Msg Cycle Time (ms) 报文周期时间 Cycle time of the message if it should be sent cyclically 报文发送周期时间（仅对周期性发送报文） Msg Length (Byte) 报文长度 Byte length of the message 报文的字节长度 Signal Name 信号名称 Signal Name 信号名称 Signal Description 信号描述 Comment for the signal 信号描述 Byte Order 排列格式 Description the byte order, intel or mortoral 描述了字节排布顺序 Start Byte 起始字节 Start Bit 起始位 Signal Send Type 信号发送类型 Send type for the signal 信号的发送类型 Bit Length (Bit) 信号长度 Bit length of the signal 信号的位长度 Date Type 数据类型 Date type of the signal 信号的数据类型 Date type: Unsigned, Signed, IEEE float, IEEE Double 数据类型：Unsigned, Signed, IEEE float, IEEE Double Resolution 精度 Resolution value is to calculate the physical value of the signal. 十六进制值的比例因子是为了计算信号的物理值。 Offset 偏移量 Offset value is to calculate the physical value of the signal. 偏移量用来计算信号的物理值。 Signal Min. Value (phys) 物理最小值 Physical minimum value of the signal in physical value 信号的物理最小值 Signal Max. Value(phys) 物理最大值 Physical maximum value of the signal in physical value 信号的物理最大值 Signal Min. Value (Hex) 总线最小值 minimum value of the signal in Hex value 信号的总线最小值 Signal Max. Value(Hex) 总线值最大值 maximum value of the signal in Hex value 信号的总线最大值 Initial Value(Hex) 初始值 If no valid signal is available after network startup, the predefined value (refer to the functional requirement) shall be sent. The valid value shall be available within this time from the startup. 如果在网络启动后没有可用的有效信号，预定义的值将被发送（取决于功能需求）。有效值必须在启动后此时间内可用。 Invalid Value(Hex) 无效值 Invalid value in hex value 十六进制表示的无效值 Inactive Value(Hex) 非使能值 Inactive value in hex value if the message sent type is ifActive and PA 十六进制表述的非使能值,仅用于使能型及周期使能型报文 Unit 单位 Unit of the signal physical value 信号物理值的单位 Signal Value Description 信号值描述 Hex-physics representation of the signal value 信号十六进制值所代表的物理值 Msg Cycle Time Fast(ms) 报文发送的快速周期(ms) The fast cycle time of message if the Msg Send Type of message is not “Cycle” 当报文发送类型不为周期型时，报文发送的快速周期。 Msg Nr. Of Reption 报文快速发送的次数 The reption number of message if the Msg Send Type of message is not “Cycle” 当报文发送类型不为周期型时，报文快速发送的次数。 Msg Delay Time(ms) 报文延时时间(ms) The min time between the same ID message if the Msg Send Type of message is not “Cycle” 当报文发送类型不为周期型时，相同ID报文之间的最小间隔。"},{"title":"Android Studio","path":"/2024/12/05/Android-Studio/","content":"项目同步失败12Could not install Gradle distribution from &#x27;https://services.gradle.org/distributions/gradle-8.7-bin.zip&#x27;.Reason: java.net.SocketTimeoutException: Connect timed out 解决方法 gradle-wrapper.properties 里的 distributionUrl 12345678#Tue Dec 03 18:35:47 CST 2024distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/dists #distributionUrl=https\\://services.gradle.org/distributions/gradle-8.9-bin.zipdistributionUrl=https\\://mirrors.cloud.tencent.com/gradle/gradle-8.9-bin.zipzipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsjiejue 关闭 Performing Analyze CodeSettings -&gt; Version Control -&gt; Commit -&gt; Analyze Code 快捷键 Ctrl + Space（Windows&#x2F;Linux）或 Command + Space（Mac）：代码自动补全。 Ctrl + D（Windows&#x2F;Linux）或 Command + D（Mac）：复制当前行。 要在 Android Studio 中启用 无线调试，让你可以通过 Wi-Fi 而不是 USB 连接来调试设备，按照以下步骤进行操作： 无线调试1. 启用开发者选项和 USB 调试首先，确保你的 Android 设备启用了开发者选项和 USB 调试功能。 启用开发者选项： 打开设备的 设置 &gt; 关于手机。 连续点击 版本号 7 次，直到看到“开发者选项已启用”的提示。 启用 USB 调试： 进入 设置 &gt; 开发者选项。 启用 USB 调试。 2. 通过 USB 连接设备并启用 TCP&#x2F;IP 调试 将你的设备通过 USB 数据线连接到计算机。 打开终端（或命令提示符），并执行以下命令： 1adb tcpip 5555 这个命令会使设备在 TCP 端口 5555 上启用无线调试。 3. 获取设备的 IP 地址 确保你的设备已连接到同一个 Wi-Fi 网络。 打开设备的 设置 &gt; Wi-Fi，找到并记下设备的 IP 地址（例如，192.168.1.101）。 4. 断开 USB 连接 现在你可以 拔掉 USB 数据线，设备仍然会处于无线调试模式。 5. 通过 Wi-Fi 连接设备在命令行中执行以下命令，使用设备的 IP 地址连接到设备： 1adb connect &lt;设备IP&gt;:5555 例如，如果设备的 IP 地址是 192.168.1.101，则执行： 1adb connect 192.168.1.101:5555 成功连接后，终端会显示： 1connected to 192.168.1.101:5555 6. 使用 Android Studio 进行调试 在 Android Studio 中，打开你正在开发的项目。 在 Run 菜单中，选择 Run 或者点击 绿色的播放按钮（Shift + F10），此时你可以选择无线连接的设备进行调试。 注意： 你可以在 Android Studio 中通过 Logcat 查看日志和进行其他调试操作，和使用 USB 调试时一样。 设备通过 Wi-Fi 调试时，可能会比 USB 调试稍慢一些，尤其是在网络不稳定时。 7. 断开无线调试如果你不再需要无线调试，可以通过以下命令断开无线调试： 1adb disconnect &lt;设备IP&gt;:5555 例如： 1adb disconnect 192.168.1.101:5555"},{"title":"Java并发编程的艺术","path":"/2024/12/05/Java并发编程的艺术/","content":"Java并发编程的艺术第1章 并发编程的挑战1.1上下文切换CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 测试上下文切换次数和时长使用Lmbench3°可以测量上下文切换的时长。 使用vmstat可以测量上下文切换的次数。 下面是利用vmstat测量上下文切换次数的示例。 S(Content Switch)表示上下文切换的次数，从上面的测试结果中我们可以看到，上下 文每1秒切换1000多次。 如何减少上下文切换无锁并发编程多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。 CAS算法Java的Atomic包使用CAS算法来更新数据，而不需要加锁。 使用最少线程避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。 协程在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。 减少上下文切换实战本节将通过减少线上大量WAITING的线程，来减少上下文切换次数。 第一步：用jstack命令dump线程信息，看看pid为3117的进程里的线程都在做什么。 1sudo -u admin /opt/ifeve/java/bin/jstack 31177 &gt;/home/tengfei.fangtf/dump17 第二步：统计所有线程分别处于什么状态，发现300多个线程处于WAITING(onobjectmonitor)状态。 1234567[tengfei,fangtfeifeve ～1§ grep java.lang.Thread.State dump17 I awk &#x27;(print $2§3§4§5)&#x27;I sort I uniq -c39 RUNNABLE21 TIMED_WAITING(onobjectmonitor)6 TIMED_WAITING(parking)51 TIMED_WAITING(sleeping)305 WAITING(onobjectmonitor)3 WAITING(parking) 第三步：打开dump文件查看处于WAITING(onobjectmonitor)的线程在做什么。发现这些线程基本全是JBOSS的工作线程，在await。说明JBOSS线程池里线程接收到的任务太少，大量线程都闲着。 1234567891011&quot;http-0.0.0.0-7001-97&quot;daemon prio=10 tid=0x000000004f6a8000 nid=0x555e inObject.wait()[0x0000000052423000]java.lang.Thread.State: WAITING(on object monitor)at java.lang.Object.wait (Native Method)-waiting on &lt;0x00000007969b2280&gt;(a org.apache.tomcat.util.net.AprEndpointSWorker)at java.lang.Object.wait(Object.java:485)at org.apache.tomcat.util.net.AprEndpointWorker,await (AprEndpoint.java:1464)-locked&lt;0x00000007969b2280&gt;(a org.apache.tomcat.util.net.AprEndpointSWorker)at org.apache.tomcat.util.net.AprEndpoint$Worker.run(AprEndpoint.java:1489)at java.lang.Thread.run(Thread.java:662) 第四步：减少JBOSS的工作线程数，找到JBOSS的线程池配置信息，将maxThreads降到100。 123456&lt;maxThreads=&quot;250&quot; maxHttpHeaderSize=&quot;8192&quot;emptySessionPath=&quot;false&quot; minSpareThreads=&quot;40&quot; maxSpareThreads=&quot;75&quot;maxPostSize=&quot;512000&quot; protocol=&quot;HTTP/1.1&quot;enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;200&quot; buffersize=&quot;16384&quot;connectionTimeout=&quot;15000&quot;disableUploadTimeout=&quot;false&quot; useBodyEncodingForURI=&quot;true&quot;&gt; 第五步：重启JBOSS,再dump线程信息，然后统计WAITING(onobjectmonitor)的线程，发现减少了175个。WAITING的线程少了，系统上下文切换的次数就会少，因为每一次从WAITTING到RUNNABLE都会进行一次上下文的切换。读者也可以使用vmstat命令测试一下。 12345678[tengfei.fangtfeifeve ～]§ grep java.lang.Thread.State dump17 I awk &#x27;(print $293§4§5)* I sort Iuniq -c44 RUNNABLE22 TIMED_WAITING(onobjectmonitor)9 TIMED_WAITING(parking)36 TIMED_WAITING(sleeping)130 WAITING(onobjectmonitor)1 WAITING(parking) 1.2死锁免死锁的几个常见方法。 避免一个线程同时获取多个锁。 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。 尝试使用定时锁，使用lock.tryLock (timeout)来替代使用内部锁机制。 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。 1.3资源限制的挑战1.什么是资源限制 资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。 2.源限制引发的问题 在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅 不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。 3.如何解决资源限制的问题 对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。 4.在资源限制情况下进行并发编程 如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度。 第2章 Java并发机制的底层实现2.1 volatile的应用可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 volatile的定义与实现原理 Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。 Java语言提供了volatile,在某些情况下比锁要更加方便。如果一个字段被声明成volatile, Java线程内存模型确保所有线程看到这个变量的值是一致的。 其实现原理相关的CPU术语与说明。 volatile是如何来保证可见性的呢? 让我们在X86处理器下通过工具获取JIT编译器生 成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。 1instance = new Singleton(); //instance是volatile变量 转变成汇编代码，如下。 10×01a3deld: movb $0×0,0×1104800(%esi);0x01a3de24:lock addl $0×0,(%esp); 有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32 架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情。 将当前处理器缓存行的数据写回到系统内存。 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内 部缓存(L1,L2或其他)后再进行操作，但操作完不知道何时会写到内存。如果对声明了 volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所 在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧 的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的 值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数 据读到处理器缓存里。 下面来具体讲解volatile的两条实现原则。 Lock前缀指令会引起处理器缓存回写到内存。 Lock前缀指令导致在执行指令期间， 声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理 器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是锁 缓存，毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对 于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目 前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相 反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子 性，此操作被称为“缓存锁定”,缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。 IA-32处理器和Intel 64处理器使用MESI(修改、独占、共享、无效)控制协议去维护内部缓存和其他处理器缓 存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理 器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其 他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果 通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那 么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。 volatile的使用优化 著名的Java并发编程大师Doug lea在JDK7的并发包里新增一个队列集合类LinkedTransferQueue,它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性 能。LinkedTransferQueue的代码如下。 123456789101112131415/**队列中的头部节点*/private transient final PaddedAtomicReference&lt;QNode&gt; head;/**队列中的尾部节点*/private transient final PaddedAtomicReference&lt;QNode&gt; tail;static final class PaddedAtomicReference &lt;T&gt; extends AtomicReference &lt;T&gt;(1使用很多4个字节的引用追加到64个字节Object p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe;PaddedAtomicReference(T r)&#123;super(r);\t&#125;&#125;public class AtomicReference &lt;V&gt; implements java.io.Serializable(private volatile V value;//省略其他代码&#125; 追加字节能优化性能? 这种方式看起来很神奇，但如果深入理解处理器架构就能理解 其中的奥秘。让我们先来看看LinkedTransferQueue这个类，它使用一个内部类类型来定义 队列的头节点(head)和尾节点(tail),而这个内部类PaddedAtomicReference相对于父类 AtomicReference只做了一件事情，就是将共享变量追加到64字节。我们可以来计算下，一 个对象的引用占4个字节，它追加了15个变量(共占60个字节),再加上父类的value变量， 一共64个字节。 为什么追加64字节能够提高并发编程的效率呢? 因为对于英特尔酷睿i7、酷睿、Atom 和NetBurst,以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个 字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的 话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的 头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机 制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操 作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和 出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾 节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。 那么是不是在使用volatile变量时都应该追加到64字节呢? 不是的。在两种场景下不应 该使用这种方式。 缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存 行是32个字节宽。 共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高 速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几 率也非常小，就没必要通过追加字节的方式来避免相互锁定。 2.2 synchronized的实现原理与应用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象。 从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出 Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在 JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。 monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何 对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。 2.2.1 Java对象头synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。 Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如表2-3所示。 在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据，如表2-4所示。 在64位虚拟机下，Mark Word是64bit大小的，其存储结构如表2-5所示。 2.2.2锁的升级与对比Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”,在Java SE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、 轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。 偏向锁 HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程访问同步块 并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID,以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里 是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败， 则需要再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁):如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁的撤销 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有 正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活 着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新 偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 图2-1中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。 关闭偏向锁 偏向锁在Java6和Java7里是默认启用的，但是它在应用程序启动几秒钟之后才激 活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay&#x3D;0。如果你 确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false,那么程序默认会进入轻量级锁状态。 轻量级锁 轻量级锁加锁 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 轻量级锁解锁 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 图2-2是两个线程同时争夺锁，导致锁膨胀的流程图。 因为自旋会消耗CPU,为了避免无用的自旋(比如获得锁的线程被阻塞住了),一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。 锁的优缺点对比 2.3原子操作的实现原理原子(atomic)本意是“不能被进一步分割的最小粒子”,而原子操作(atomic operation) 意为“不可被中断的一个或一系列操作”。 术语定义 处理器如何实现原子操作 使用总线锁保证原子性 所谓总线锁就是使用处理器提供的一个 LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么 该处理器可以独占共享内存。 使用缓存锁保证原子性 频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直 接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使 用“缓存锁定”的方式来实现复杂的原子性。 Java如何实现原子操作 使用循环CAS实现原子操作 JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现 的基本思路就是循环进行CAS操作直到成功为止。 CAS实现原子操作的三大问题 ABA问题。 因为CAS需要在操作值的时候，检查值有没有发生变化，如果没 有发生变化则更新，但是如果一个值原来是A,变成了B,又变成了A,那么使用CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。 ABA问题的解决思路 就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1,那么 A→B→A就会变成1A→2B→3A。 Java 1.5开始，JDK的Atomic包里提供了一个类 AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检 查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以 原子方式将该引用和该标志的值设置为给定的更新值。 123456public boolean compareAndSet(V expectedReference,V newReference,int eptedStamp,int newStamp) 循环时间长开销大。 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开 销。 只能保证一个共享变量的原子操作。 当对一个共享变量执行操作时，我们可以使用 循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作 的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共 享变量来操作。 比如，有两个共享变量i&#x3D;2j&#x3D;a,合并一下ij&#x3D;2a,然后用CAS来操作ij。 从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把 多个变量放在一个对象里来进行CAS操作。 使用锁机制实现原子操作 锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循 环CAS,即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步 块的时候使用循环CAS释放锁。 第3章 Java内存模型3.1 Java内存模型的基础3.1.1 并发编程模型的两个关键问题在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步(这里 的线程是指并发执行的活动实体)。通信是指线程之间以何种机制来交换信息。 在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状 态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发 送消息来显式进行通信。 同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型 里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执 行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。 Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。 3.1.2 Java内存模型的抽象结构在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间 共享(本章用“共享变量”这个术语代指实例域，静态域和数组元素)。局部变量(Local Variables),方法定义参数(Java语言规范称之为Formal Method Parameters)和异常处理器参 数(Exception Handler Parameters)不会在线程之间共享，它们不会有内存可见性问题，也不 受内存模型的影响。 Java线程之间的通信由Java内存模型(本文简称为JMM)控制，JMM决定一个线程对 共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间 的抽象关系：线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私 有的本地内存(Local Memory),本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内 存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的 硬件和编译器优化。 Java内存模型的抽象示意如图3-1所示。 从图3-1来看，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。 线程A把本地内存A中更新过的共享变量刷新到主内存中去。 线程B到主内存中去读取线程A之前已更新过的共享变量。 下面通过示意图(见图3-2)来说明这两个步骤。 如图3-2所示，本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时， 这3个内存中的x值都为0。线程A在执行时，把更新后的x值(假设值为1)临时存放在 自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修 改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读 取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。 从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必 须要经过主内存。 JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序 员提供内存可见性保证。 3.1.3从源代码到指令序列的重排序在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种 类型。 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语 句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术(Instruction-Level Parallelism,ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对 应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看 上去可能是在乱序执行。 从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图3-3 所示。 上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多 线程程序出现内存可见性问题。 对于编译器，JMM的编译器重排序规则会禁止特定类型 的编译器重排序(不是所有的编译器重排序都要禁止)。 对于处理器重排序，JMM的处理 器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers,Intel称之为Memory Fence)指令，通过内存屏障指令来禁正特定类型的处理器 重排序。 JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过 禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 3.1.4并发编程模型的分类第4章 Java并发编程基础4.1 线程简介4.1.1什么是线程现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序， 操作系统就会创建一个Java进程。 现代操作系统调度的最小单元是线程，也叫轻量级进程 (Light Weight Process),在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆 栈和局部变量等属性，并且能够访问共享的内存变量。 Java程序天生就是多线程程序，因为执行main(方法的是一个名称 为main的线程。下面使用JMX来查看一个普通的Java程序包含哪些线程，如代码清单4-1 所示。 可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其 他线程的同时运行。 4.1.2 为什么要使用多线程 更多的处理器核心 使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。 更快的响应时间 使用多线程技术，即将数据一致性不强的操作派发给其他线程处理(也可以使用消息队列),如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。 更好的编程模型 Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将其多线程化。一旦开发人员建立好了模型，稍做修改总是能够方便地映射到Java提供的多线程编程模型上。 4.1.3 线程优先级现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。 在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从 1～10,在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5,优 先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞 (休眠或者I&#x2F;O操作)的线程需要设置较高优先级，而偏重计算(需要较多CPU时间或者偏运 算)的线程则设置较低的优先级，确保处理器不会被独占。 在不同的JVM以及操作系统上， 线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定，示例如代码清单4-2 所示。 从输出可以看到线程优先级没有生效，优先级1和优先级10的Job计数的结果非常相 近，没有明显差距。这表示程序正确性不能依赖线程的优先级高低。 注意：线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程 对于优先级的设定。笔者的环境为：Mac OS X10.10,Java版本为1.7.0_71,经过笔 者验证该环境下所有Java线程优先级均为5(通过jstack查看),对线程优先级的设 置会被忽略。另外，尝试在Ubuntu 14.04环境下运行该示例，输出结果也表示该环境 忽略了线程优先级的设置。 4.1.4 线程的状态Java线程在运行的生命周期中可能处于表4-1所示的6种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态。 下面我们使用jstack工具(可以选择打开终端，键入jstack或者到JDK安装目录的bin 目录下执行命令),尝试查看示例代码运行时的线程信息，更加深入地理解线程状态，示例如 代码清单4-3所示。 上述示例中使用的SleepUtils如代码清单4-4所示。 运行该示例，打开终端或者命令提示符，键入“jps”,输出如下。 1234611935 Jps929 ThreadState270 可以看到运行示例对应的进程ID是929,接着再键入“jstack 929”(这里的进程ID需要 和读者自己键入jps得出的ID一致),部分输出如下所示。 12345678910111213141516BlockedThread-2线程阻塞在获取Blocked,class示例的锁上&quot;BlockedThread-2&quot; prio=5 tid=0x00007feacb05d000 nid=0x5d03 waiting for monitorentry [0x000000010fd58000]java.lang.Thread.State: BLOCKED(on object monitor)BlockedThread-1线程获取到了Blocked.class的锁&quot;BlockedThread-1&quot; prio=5 tid=0x00007feacb05a000 nid=0x5b03 waiting on condition[0x000000010fc55000]java.lang.Thread.State: TIMED_WAITING(sleeping)WaitingThread线程在Waiting实例上等待&quot;WaitingThread&quot; prio=5 tid=0x00007feacb059800 nid=0x5903 in Object.wait()[0×000000010fb52000]java.lang.Thread.State: WAITING(on object monitor)TimeWaitingThread线程处于超时等待&quot;TimeWaitingThread&quot; prio=5 tid=0x00007feacb058800 nid=0x5703 waiting on condition[0x000000010fa4f0001java.lang.Thread.State: TIMED_WAITING(sleeping) 通过示例，我们了解到Java程序运行中线程状态的具体含义。线程在自身的生命周期 中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如图4-1示。 由图4-1中可以看到，线程创建之后，调用start()方法开始运行。当线程执行wait()方 法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运 行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达 时将会返回到运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。 注意：Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在 进入synchronized关键字修饰的方法或代码块(获取锁)时的状态，但是阻塞在java. concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock 接口对于阻塞的实现均使用了LockSupport类中的相关方法。 4.1.5 Daemon线程Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。 这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以 通过调用Thread.setDaemon(true)将线程设置为Daemon线程。 注意：Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。 Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的 finally块并不一定会执行，示例如代码清单4-5所示。 运行Daemon程序，可以看到在终端或者命令提示符上没有任何输出。main线程(非Daemon线程)在启动了线程DaemonRunner之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线 程都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没 有执行。 注意：在构建Dacmon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。 4.2启动和终止线程4.2.1 构造线程在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要 的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。代码清单4-6所 示的代码摘自java.lang.Thread中对线程进行初始化的部分。 在上述过程中，一个新构造的线程对象是由其parent线程来进行空间分配的，而child 线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的 ThreadLocal,同时还会分配一个唯一的ID来标识这个child线程。 4.2.2 启动线程线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程(即parent线程)同步告知Java虚拟机，只要线程规划器空闲，应立即启 动调用start()方法的线程。 注意：启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。 4.2.3 理解中断中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行 了中断操作。 线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是 否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如 果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。 从Java的API中可以看到，许多声明抛出InterruptedException的方法(例如Thread. sleep(long millis)方法)这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException,此时调用isInterrupted()方法将会返回 false。 在代码清单4-7所示的例子中，首先创建了两个线程，SleepThread和BusyThread,前 者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。 从结果可以看出，抛出InterruptedException的线程SleepThread,其中断标识位被清除 了，而一直忙碌运作的线程BusyThread,中断标识位没有被清除。 4.2.4 过期的suspend()、resume()和stop()大家对于CD机肯定不会陌生，如果把它播放音乐比作一个线程的运作，那么对音乐 播放做出的暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和 stop()。 在代码清单4-8所示的例子中，创建了一个线程PrintThread,它以1秒的频率进行打 印，而主线程对其进行暂停、恢复和停止操作。 在执行过程中，PrintThread运行了3秒，随后被暂停，3秒后恢复，最后经过3秒被终止。 通过示例的输出可以看到，suspend0、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。 不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源(比如锁),而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。 注意：正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而暂停和恢复操作可以用后面提到的等待&#x2F;通知机制来替代。 4.2.5 安全地终止线程在4.2.3节中提到的中断状态是线程的一个标识位，而中断操作是一种简便的线程间 交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个 boolean变量来控制是否需要停止任务并终止该线程。 在代码清单4-9所示的例子中，创建了一个线程CountThread,它不断地进行变量累加， 而主线程尝试对其进行中断操作和停止操作。 输出结果如下所示(输出内容可能不同)。 12Count i = 543487324Count i = 540898082 示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终 止。这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。 4.3线程间通信4.3.1 volatile和synchronized关键字关键字volatile可以用来修饰字段(成员变量),就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访 问的可见性。 关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。 在代码清单4-10所示的例子中，使用了同步块和同步方法，通过使用javap工具查看生 成的class文件信息来分析synchronized关键字的实现细节，示例如下。 在Synchronized.class同级目录执行javap-v Synchronized.class,部分相关输出如下所示： 上面class信息中，对于同步块的实现使用了monitorenter和monitorexit指令，而同步 方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。无论采用哪种方式，其本 质是对一个对象的监视器(monitor)进行获取，而这个获取过程是排他的，也就是同一时刻 只能有一个线程获取到由synchronized所保护对象的监视器。 任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而 没有获取到监视器(执行该方法)的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。 图4-2描述了对象、对象的监视器、同步队列和执行线程之间的关系 从图4-2中可以看到，任意线程对Object(Object由synchronized保护)的访问，首先要 获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访 问Object的前驱(获得了锁的线程)释放了锁，则该释放操作唤醒阻塞在同步队列中的线程， 使其重新尝试对监视器的获取。 4.3.2 等待&#x2F;通知机制等待&#x2F;通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超 类java.lang.Object上，方法和描述如表4-2所示。 等待&#x2F;通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait() 方法返回，进而执行后续操作。 在代码清单4-11所示的例子中，创建了两个线程——WaitThread和NotifyThread,前者 检查flag值是否为false,如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠 了一段时间后对lock进行通知，示例如下所示。 上述第3行和第4行输出的顺序可能会互换，而上述例子主要说明了调用wait()、 notify()以及notifyAll()时需要注意的细节，如下。 使用wait()、notify()和notifyAll()时需要先对调用对象加锁。 调用wait()方法后，线程状态由RUNNING变为WAITING,并将当前线程放置到对 象的等待队列。 notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用 notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。 notify(方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而 notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由 WAITING变为BLOCKED。 从wait()方法返回的前提是获得了调用对象的锁。 从上述细节中可以看到，等待&#x2F;通知机制依托于同步机制，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。 图4-3描述了上述示例的过程。 在图4-3中，WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了 锁并进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁， NotifyThread随后获取了对象的锁，并调用对象的notify(方法，将WaitThread从WaitQueue 移到SynchronizedQucue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之 后，WaitThread再次获取到锁并从wait()方法返回继续执行。 4.3.3 等待&#x2F;通知的经典范式从4.3.2节中的WaitNotify示例中可以提炼出等待&#x2F;通知的经典范式，该范式分为两部分，分别针对等待方(消费者)和通知方(生产者)。 等待方遵循如下原则。 获取对象的锁。 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。 条件满足则执行对应的逻辑。 对应的伪代码如下。 123456synchronized(对象)(\twhile(条件不满足)( 对象.wait();\t&#125;\t对应的处理逻辑) 通知方遵循如下原则。 获得对象的锁。 改变条件。 通知所有等待在对象上的线程。 对应的伪代码如下。 1234synchronized(对象)(\t改变条件\t对象.notifyAl1();&#125; 4.3.4 管道输入&#x2F;输出流管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。 管道输入&#x2F;输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter,前两种面向字节，而后两种面向字符。 在代码清单4-12所示的例子中，创建了printThread,它用来接受main线程的输入，任 何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。 运行该示例，输入一组字符串，可以看到被printThread进行了原样输出。 12Repeat my words.Repeat my words. 对于Piped类型的流，必须先要进行绑定，也就是调用connect(方法，如果没有将输入&#x2F; 输出流绑定起来，对于该流的访问将会抛出异常。 4.3.5 Thread.join()的使用如果一个线程A执行了threadjoin()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis, int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线 程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。 在代码清单4-13所示的例子中，创建了10个线程，编号0～9,每个线程调用前一个 线程的join()方法，也就是线程0结束了，线程1才能从join()方法中返回，而线程0需要等待main线程结束。 输出如下。 1234567891011main terminate.0 terminate.1 terminate.2 terminate.3 terminate.4 terminate.5 terminate.6 terminate.7 terminate.8 terminate.9 terminate. 从上述输出可以看到，每个线程终止的前提是前驱线程的终止，每个线程等待前驱线程 终止后，才从join()方法返回，这里涉及了等待&#x2F;通知机制(等待前驱线程结束，接收前驱线程结束通知)。 代码清单4-14是JDK中Thread.join()方法的源码(进行了部分调整)。 当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的 线程。可以看到join()方法的逻辑结构与4.3.3节中描述的等待&#x2F;通知经典范式一致，即加 锁、循环和处理逻辑3个步骤。 4.3.6 ThreadLocal的使用ThreadLocal,即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结 构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑 定在这个线程上的一个值。 可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。 在代码清单4-15所示的例子中，构建了一个常用的Profiler类，它具有begin(和end()两个 方法，而end(方法返回从begin()方法调用开始到end(方法被调用时的时间差，单位是毫秒。 Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法， 在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中，比如在 AOP(面向方面编程)中，可以在方法调用前的切人点执行begin()方法，而在方法调用后的切入点执行end()方法，这样依旧可以获得方法的执行耗时。 4.4线程应用实例4.4.1 等待超时模式开发人员经常会遇到这样的方法调用场景：调用一个方法时等待一段时间(一般来说是 给定一个时间段),如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。 前面的章节介绍了等待&#x2F;通知的经典范式，即加锁、条件循环和处理逻辑3个步骤，而 这种范式无法做到超时等待。而超时等待的加入，只需要对经典范式做出非常小的改动，改动内容如下所示。 假设超时时间段是T,那么可以推断出在当前时间now+T之后就会超时。 定义如下变量。 等待持续时间：REMAINING&#x3D;T。 超时时间：FUTURE&#x3D;now+T。 这时仅需要wait(REMAINING)即可，在wait(REMAINING)返回之后会将执行： REMAINING&#x3D;FUTURE-now。如果REMAINING小于等于0,表示已经超时，直接退出， 否则将继续执行wait(REMAINING)。 上述描述等待超时模式的伪代码如下。 可以看出，等待超时模式就是在等待&#x2F;通知范式基础上增加了超时控制，这使得该模式 相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而 是会按照调用者的要求“按时”返回。 4.4.2一个简单的数据库连接池示例我们使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在 1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。设定连接池的大小为10 个，然后通过调节客户端的线程数来模拟无法获取连接的场景。 首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列 来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连 接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示 例如代码清单4-16所示。 4.4.3线程池技术及其示例第5章 Java中的锁第6章 Java并发容器和框架第7章 Java中的13个原子操作类(√)Java从JDK 1.5开始提供了java.util.concurrent.atomic包(以下简称Atomic包),这个 包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。 因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是**原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)**。Atomic包里的类基本都是使用Unsafe实现的包装类。 7.1 原子更新基本类型类使用原子的方式更新基本类型，Atomic包提供了以下3个类。 AtomicBoolean:原子更新布尔类型。 AtomicInteger:原子更新整型。 AtomicLong:原子更新长整型。 以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下。 int addAndGet(int delta):以原子方式将输入的数值与实例中的值(AtomicInteger里 的value)相加，并返回结果。 boolean compareAndSet(int expect,int update):如果输入的数值等于预期值，则以原 子方式将该值设置为输入的值。 int getAndIncrement():以原子方式将当前值加1,注意，这里返回的是自增前的值。 void lazySet(int newValue):最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 int getAndSet(int newValue):以原子方式设置为newValue的值，并返回旧值。 AtomicInteger示例代码如代码清单7-1所示。 那么getAndIncrement是如何实现原子操作的呢?让我们一起分析其实现原理， getAndIncrement的源码如代码清单7-2所示。 源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger 的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该 方法先检查当前数值是否等于current,等于意味着AtomicInteger的值没有被其他线程修改 过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回 false,程序会进入for循环重新进行compareAndSet操作。 Atomic包提供了3种基本类型的原子更新，但是Java的基本类型里还有char、float和 double等。那么问题来了，如何原子的更新其他的基本类型呢?Atomic包里的类基本都是 使用Unsafe实现的，让我们一起看一下Unsafe的源码，如代码清单7-3所示。 通过代码，我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong,再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS,所以原子更新char、float和double变量 也可以用类似的思路来实现。 7.2 原子更新数组通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类。 AtomicIntegerArray:原子更新整型数组里的元素。 AtomicLongArray:原子更新长整型数组里的元素。 AtomicReferenceArray:原子更新引用类型数组里的元素。 AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下。 int addAndGet(inti,int delta):以原子方式将输入值与数组中索引i的元素相加。 boolean compareAndSet(int i, int expect, int update):如果当前值等于预期值，则 以原子方式将数组位置i的元素设置成update值。 以上几个类提供的方法几乎一样，所以本节仅以AtomicIntegerArray为例进行讲解， AtomicIntegerArray的使用实例代码如代码清单7-4所示。 需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前 数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的 数组。 7.3 原子更新引用类型原子更新基本类型的AtomicInteger,只能更新一个变量，如果要原子更新多个变量，就 需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。 AtomicReference:原子更新引用类型。 AtomicReferenceFieldUpdater:原子更新引用类型里的字段。 AtomicMarkableReference:原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef, boolean initialMark)。 以上几个类提供的方法几乎一样，所以本节仅以AtomicReference为例进行讲解， AtomicReference的使用示例代码如代码清单7-5所示。 代码中首先构建一个user对象，然后把user对象设置进AtomicReferenc中，最后调用 compareAndSet方法进行原子更新操作，实现原理同AtomicInteger里的compareAndSet方 法。代码执行后输出结果如下。 12Shinichi 17 7.4 原子更新字段类如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供 了以下3个类进行原子字段更新。 AtomicIntegerFieldUpdater:原子更新整型的字段的更新器。 AtomicLongFieldUpdater:原子更新长整型字段的更新器。 AtomicStampedReference:原子更新带有版本号的引用类型。该类将整数值与引用关 联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。 要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段(属性)必须使用public volatile修饰符。 以上3个类提供的方法几乎一样，所以本节仅以AstomicIntegerFieldUpdater为例进行讲解，AstomicIntegerFieldUpdater的示例代码如代码清单7-6所示。 第8章 Java中的并发工具类在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier 和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间 交换数据的一种手段。 8.1等待多线程完成的CountDownLatchCountDownLatch允许一个或多个线程等待其他线程完成操作。 假如有这样一个需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使 用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提 示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的 做法是使用join()方法，如代码清单8-1所示。 join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否 存活，如果join线程存活则让当前线程永远等待。其中，wait(0)表示永远等待下去，代码 片段如下。 123while (isAlive())&#123;wait(0);&#125; 直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在 JVM里实现的，所以在JDK里看不到，大家可以查看JVM源码。 在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比 join的功能更多，如代码清单8-2所示。 CountDownLatch的构造函数接收一个int类型的参数 作为计数器，如果你想等待N个点 完成，这里就传入N。 当我们调用CountDownLatch的countDown方法时，N就会减1,CountDownLatch的 await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以 这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程 时，只需要把这个CountDownLatch的引用传递到线程里即可。 如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以 使用另外一个带指定时间的await方法——await(long time,TimeUnit unit),这个方法等待 特定时间后，就会不再阻塞当前线程。join也有类似的方法。 注意：计数器必须大于等于0,只是等于0时候，计数器就是零，调用await方法时不会阻 塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的 内部计数器的值。一个线程调用countDown方法happen-before,另外一个线程调用 await方法。 8.2同步屏障CyclicBarrierCyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做的事情是，让 一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障 才会开门，所有被屏障拦截的线程才会继续运行。 8.2.1 CyclicBarrier简介CyclicBarrier默认的构造方法是CyclicBarrier(int parties),其参数表示屏障拦截的线程 数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。 示例代码如代码清单8-3所示。 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生 两种输出，第一种可能输出如下。 1212 第二种可能输出如下。 1221 如果把new CyclicBarrier(2)修改成new CyclicBarrier(3),则主线程和子线程会永远等 待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障 的两个线程都不会继续执行。 CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties,Runnable barrierAction),用于在线程到达屏障时，优先执行barrierAction,方便处理更复杂的业务场景，如 代码清单8-4所示。 因为CyclicBarrier设置了拦截线程的数量是2,所以必须等代码中的第一个线程和线程 A都执行完之后，才会继续执行主线程，然后输出2,所以代码执行后的输出如下。 123312 8.2.2 CyclicBarrier的应用场CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。 例如，用一个Excel 保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计 用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个 sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel 的日均银行流水，如代码清单8-5所示。 使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1,再 由BankWaterService线程汇总4个sheet计算出的结果，输出结果如下。 14 8.2.3 CyclicBarrier和CountDownLatch的区别CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。 CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。代码清单8-5执 行完之后会返回true,其中isBroken的使用代码如代码清单8-6所示。 8.3控制并发线程数的SemaphoreSemaphore(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程， 以保证合理的使用公共资源。 1.应用场景 Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十 个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有 10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获 取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如代码清单8-7所示。 在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方 法Semaphore(int permits)接受一个整型的数字，表示可用的许可证数量。Semaphore(10) 表示允许10个线程获取许可证，也就是最大并发数是10。 Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还 许可证。还可以用tryAcquire()方法尝试获取许可证。 2.其他方法 - intavailablePermits():返回此信号量中当前可用的许可证数。 - intgetQueueLength():返回正在等待获取许可证的线程数。 - booleanhasQueuedThreads():是否有线程正在等待获取许可证。 - void reducePermits(int reduction):减少reduction个许可证，是个protected方法。 - Collection getQueuedThreads():返回所有等待获取许可证的线程集合，是个protected 方法。 8.4线程间交换数据的ExchangerExchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数 据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通 过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线 程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线 程生产出来的数据传递给对方。 第9章 Java中的线程池Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资 源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 9.1线程池的实现原理当向线程池提交一个任务之后，线程池是如何处理这个任务的呢? 处理流程图如图9-1所示。 从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工 作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。 线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在 这个工作队列里。如果工作队列满了，则进入下个流程。 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线 程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 ThreadPoolExecutor执行execute()方法的示意图，如图9-2所示。 ThreadPoolExecutor执行execute方法分下面4种情况。 如果当前运行的线程少于corePoolSize,则创建新线程来执行任务(注意，执行这一 步骤需要获取全局锁)。 如果运行的线程等于或多于corePoolSize,则将任务加入BlockingQueue。 如果无法将任务加入BlockingQueue(队列已满),则创建新的线程来处理任务(注意， 执行这一步骤需要获取全局锁)。 如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝，并调 用RejectedExecutionHandler.rejectedExecution()方法。 ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽 可能地避免获取全局锁(那将会是一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热 之后(当前运行的线程数大于等于corePoolSize),几乎所有的execute()方法调用都是执行步 骤2,而步骤2不需要获取全局锁。 源码分析：上面的流程分析让我们很直观地了解了线程池的工作原理，让我们再通过源 代码来看看是如何实现的，线程池执行任务的方法如下。 工作线程：线程池创建线程时，会将线程封装成工作线程Worker,Worker在执行完任 务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到 这点。 ThreadPoolExecutor中线程执行任务的示意图如图9-3所示。 线程池中的线程执行任务分两种情况，如下。 在execute()方法中创建一个线程时，会让这个线程执行当前任务。 这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。 9.2线程池的使用9.2.1线程池的创建可以通过ThreadPoolExecutor来创建一个线程池。 12new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,milliseconds,runnableTaskQueue, handler); 创建一个线程池时需要输入几个参数，如下。 corePoolSize(线程池的基本大小):当提交一个任务到线程池时，线程池会创建一个 线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的 任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads(方 法，线程池会提前创建并启动所有基本线程。 runnableTaskQueue(任务队列):用于保存等待执行的任务的阻塞队列。可以选择以 下几个阻塞队列。 ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先 出)原则对元素进行排序。 LinkedBlockingQueue:一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞 吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool() 使用了这个队列。 SynchronousQueue:一个不存储元素的阻塞队列。每个插入操作必须等到另一个 线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQucue,静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue:一个具有优先级的无限阻塞队列。 maximumPoolSize(线程池最大数量):线程池允许创建的最大线程数。如果队列满 了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意 的是，如果使用了无界的任务队列这个参数就没什么效果。 ThreadFactory:用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线 程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池 里的线程设置有意义的名字，代码如下。 1new ThreadFactoryBuilder().setNameFormat(&quot;xx-task-sd&quot;).build(); RejectedExecutionHandler(饱和策略):当队列和线程池都满了，说明线程池处于饱 和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy,表 示无法处理新任务时抛出异常。在JDK1.5中Java线程池框架提供了以下4种策略。 AbortPolicy:直接抛出异常。 CallerRunsPolicy:只用调用者所在线程来运行任务。 DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy:不处理，丢弃掉。 当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如 记录日志或持久化存储不能处理的任务。 keepAliveTime(线程活动保持时间):线程池的工作线程空闲后，保持存活的时间。 所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的 利用率。 TimeUnit(线程活动保持时间的单位):可选的单位有天(DAYS)、小时(HOURS)、 分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS,千分之一毫 秒)和纳秒(NANOSECONDS,千分之一微秒)。 9.2.2向线程池提交任务可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。 submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过 这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回 值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout,TimeUnit unit)方法 则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 9.2.3关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断 的任务可能永远无法终止。 shutdownNow首先将线程池的状态设 置成STOP,然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。 shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任 务的线程。 只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调 用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法 来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。 9.2.4合理地配置线程池要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 任务的优先级：高、中和低。 任务的执行时间：长、中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的 线程，如配置N+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则 应配置尽可能多的线程，如2*N。混合型的任务，如果可以拆分，将其拆分成一个CPU密 集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执 行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分 解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级 高的任务先执行。 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让 执行时间短的任务先执行。 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。 建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃 任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台 任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全 部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来 越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们 的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任 务，但是出现这样问题时也会影响到其他任务。 9.2.5线程池的监控如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以 根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池 的时候可以使用以下属性。 taskCount:线程池需要执行的任务数量。 completedTaskCount:线程池在运行过程中已完成的任务数量，小于或等于taskCount。 largestPoolSize:线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程 池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 getPoolSize:线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动 销毁，所以这个大小只增不减。 getActiveCount:获取活动的线程数。 通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭 前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时 间等。这几个方法在线程池里是空方法。 1protected void beforeExecute(Thread t, Runnable r)() 第10章 Executor框架在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们 为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时， 为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。 Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作单元与执行机制分离 开来。工作单元包括Runnable和Callable,而执行机制由Executor框架提供。 10.1 Executor框架简介10.1.1 Executor框架的两级调度模型在HotSpot VM的线程模型中，Java线程(java.lang.Thread)被一对一映射为本地操作系 统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系 统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。 在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器 (Executor框架)将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射 到硬件处理器上。这种两级调度模型的示意图如图10-1所示。 从图中可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系 统内核控制，下层的调度不受应用程序的控制。 10.1.2 Executor框架的结构与成员 Executor框架的结构 Executor框架主要由3大部分组成如下。 任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。 任务的执行。包括任务执行机制的核心接口Executor,以及继承自Executor的 ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口 (ThreadPoolExecutor和ScheduledThreadPoolExecutor)。 异步计算的结果。包括接口Future和实现Future接口的FutureTask类。 Executor框架包含的主要的类与接口如图10-2所示。 下面是这些类和接口的简介。 Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离 开来。 ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。 ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定 期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。 Future接口和实现Future接口的FutureTask类，代表异步计算的结果。 Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。 Executor框架的使用示意图如图10-3所示。 主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可 以把一个Runnable对象封装为一个Callable对象(Executors.callable(Runnable task)或 Executors.callable(Runnable task, Object resule))。 然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute (Runnable command));或者也可以把Runnable对象或Callable对象提交给ExecutorService执行(ExecutorService.submit(Runnable task)或ExecutorService.submit (Callable task))。 如果执行ExecutorService.submit(…),ExecutorService将返回一个实现Future接口的 对象(到目前为止的JDK中，返回的是FutureTask对象)。由于FutureTask实现了Runnable, 程序员也可以创建FutureTask,然后直接交给ExecutorService执行。 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptlfRunning)来取消此任务的执行。 Executor框架的成员 第11章 Java并发编程实践11.1生产者和消费者模式在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生 产线程和消费线程的工作能力来提高程序整体处理数据的速度。 在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程 开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费 者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消 费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费 者模式。 什么是生产者和消费者模式 生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一 个第三者出来进行解耦，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在 学习一些设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。 11.1.1 生产者消费者模式实战我和同事一起利用业余时间开发的Yuna工具中使用了生产者和消费者模式。我先介绍 下Yuna°工具，在阿里巴巴很多同事都喜欢通过邮件分享技术文章，因为通过邮件分享很方 便，大家在网上看到好的技术文章，执行复制→粘贴→发送就完成了一次分享，但是我发现 技术文章不能沉淀下来，新来的同事看不到以前分享的技术文章，大家也很难找到以前分享 过的技术文章。为了解决这个问题，我们开发了一个Yuna工具。 我们申请了一个专门用来收集分享邮件的邮箱，比如&#x73;&#104;&#x61;&#114;&#101;&#64;&#x61;&#x6c;&#105;&#98;&#x61;&#x62;&#x61;&#46;&#x63;&#111;&#x6d;,大家将分享 的文章发送到这个邮箱，让大家每次都抄送到这个邮箱肯定很麻烦，所以我们的做法是将这 个邮箱地址放在部门邮件列表里，所以分享的同事只需要和以前一样向整个部门分享文章就 行。Yuna工具通过读取邮件服务器里该邮箱的邮件，把所有分享的邮件下载下来，包括邮 件的附件、图片和邮件回复。因为我们可能会从这个邮箱里下载到一些非分享的文章，所以 我们要求分享的邮件标题必须带有一个关键字，比如“内贸技术分享”。下载完邮件之后， 通过confluence的Web Service接口，把文章插入到confluence里，这样新同事就可以在 confluence里看以前分享过的文章了，并且Yuna工具还可以自动把文章进行分类和归档。 为了快速上线该功能，当时我们花了3天业余时间快速开发了Yuna 1.0版本。在1.0版 本中并没有使用生产者消费模式，而是使用单线程来处理，因为当时只需要处理我们一个部 门的邮件，所以单线程明显够用，整个过程是串行执行的。在一个线程里，程序先抽取全部 的邮件，转化为文章对象，然后添加全部的文章，最后删除抽取过的邮件。代码如下。 Yuna工具在推广后，越来越多的部门使用这个工具，处理的时间越来越慢，Yuna是每 隔5分钟进行一次抽取的，而当邮件多的时候一次处理可能就花了几分钟，于是我在Yuna 2.0版本里使用了生产者消费者模式来处理邮件，首先生产者线程按一定的规则去邮件系统 里抽取邮件，然后存放在阻塞队列里，消费者从阻塞队列里取出文章后插入到conflunce里。 代码如下。 代码的执行逻辑是，生产者启动一个线程把所有邮件全部抽取到队列中，消费者启动 CPU*2个线程数处理邮件，从之前的单线程处理邮件变成了现在的多线程处理，并且抽取邮 件的线程不需要等处理邮件的线程处理完再抽取新邮件，所以使用了生产者和消费者模式 后，邮件的整体处理速度比以前要快了几倍。 11.1.2多生产者和多消费者场景在多核时代，多线程并发处理速度比单 线程处理速度更快，所以可以使用多个线程 来生产数据，同样可以使用多个消费线程来 消费数据。而更复杂的情况是，消费者消费 的数据，有可能需要继续处理，于是消费者 处理完数据之后，它又要作为生产者把数据 放在新的队列里，交给其他消费者继续处理， 如图11-1所示。 我们在一个长连接服务器中使用了这种 模式，生产者1负责将所有客户端发送的消息存放在阻塞队列1里，消费者1从队列里读消息，然后通过消息ID进行散列得到N个队 列中的一个，然后根据编号将消息存放在到不同的队列里，每个阻塞队列会分配一个线程来 消费阻塞队列里的数据。如果消费者2无法消费消息，就将消息再抛回到阻塞队列1中，交 给其他消费者处理。 以下是消息总队列的代码。 启动一个消息分发线程。在这个线程里子队列自动去总队列里获取消息。 使用散列(hash)算法获取一个子队列，代码如下。 使用的时候，只需要往总队列里发消息。 11.1.3线程池与生产消费者模式Java中的线程池类其实就是一种生产者和消费者模式的实现方式，但是我觉得其实现方 式更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务 数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实 现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。 我们的系统也可以使用线程池来实现多生产者和消费者模式。例如，创建N个不同规模 的Java线程池来处理不同性质的任务，比如线程池1将数据读到内存之后，交给线程池2里 的线程继续处理压缩数据。线程池1主要处理IO密集型任务，线程池2主要处理CPU密集 型任务。 本节讲解了生产者和消费者模式，并给出了实例。读者可以在平时的工作中思考一下哪些场景可以使用生产者消费者模式，我相信这种场景应该非常多，特别是需要处理任务时间比较长的场景，比如上传附件并处理，用户把文件上传到系统后，系统把文件丢到队列里， 然后立刻返回告诉用户上传成功，最后消费者再去队列里取出文件处理。再如，调用一个远 程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用 线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一 个接口取数据。 11.2 线上问题定位有时候，有很多问题只有在线上或者预发环境才能发现，而线上又不能调试代码，所以 线上问题定位就只能看日志、系统状态和dump线程，本节只是简单地介绍一些常用的工具， 以帮助大家定位线上问题。 在Linux命令行下使用TOP命令查看每个进程的情况，显示如下。 我们的程序是Java应用，所以只需要关注COMMAND是Java的性能数据，COMMAND 表示启动当前进程的命令，在Java进程这一行里可以看到CPU利用率是300不用担心， 这个是当前机器所有核加在一起的CPU利用率。 再使用top的交互命令数字1查看每个CPU的性能数据。 命令行显示了CPU4,说明这是一个5核的虚拟机，平均每个CPU利用率在60%上。 如果这里显示CPU利用率100则很有可能程序里写了一个死循环。这些参数的含义，可 以对比表11-1来查看。 使用top的交互命令H查看每个线程的性能信息。 在这里可能会出现3种情况。 第一种情况，某个线程CPU利用率一直100则说明是这个线程有可能有死循环， 那么请记住这个PID。 第二种情况，某个线程一直在TOP10的位置，这说明这个线程可能有性能问题。 第三种情况，CPU利用率高的几个线程在不停变化，说明并不是由某一个线程导致 CPU偏高。 如果是第一种情况，也有可能是GC造成，可以用jstat命令看一下GC情况，看看是不 是因为持久代或年老代满了，产生FullGC,导致CPU利用率持续飙高，命令和回显如下。 还可以把线程dump下来，看看究竟是哪个线程、执行什么代码造成的CPU利用率高。 执行以下命令，把线程dump到文件dump17里。执行如下命令。 dump出来的线程ID(nid)是十六进制的，而我们用TOP命令看到的线程ID是十进制 的，所以要用printf命令转换一下进制。然后用十六进制的ID去dump里找到对应的线程。 1printf &quot;x &quot; 31558 输出：7b46。 11.3性能测试因为要支持某个业务，有同事向我们提出需求，希望系统的某个接口能够支持2万的 QPS,因为我们的应用部署在多台机器上，要支持两万的QPS,我们必须先要知道该接口在单机上能支持多少QPS,如果单机能支持1千QPS,我们需要20台机器才能支持2万的QPS。 需要注意的是，要支持的2万的QPS必须是峰值，而不能是平均值，比如一天当中有23个小 时QPS不足1万，只有一个小时的QPS达到了2万，我们的系统也要支持2万的QPS。 我们先进行性能测试。我们使用公司同事开发的性能测试工具进行测试，该工具的原理 是，用户写一个Java程序向服务器端发起请求，这个工具会启动一个线程池来调度这些任 务，可以配置同时启动多少个线程、发起请求次数和任务间隔时长。将这个程序部署在多台 机器上执行，统计出QPS和响应时长。我们在10台机器上部署了这个测试程序，每台机器 启动了100个线程进行测试，压测时长为半小时。注意不能压测线上机器，我们压测的是开 发服务器。 测试开始后，首先登录到服务器里查看当前有多少台机器在压测服务器，因为程序的端 口是12200,所以使用netstat命令查询有多少台机器连接到这个端口上。命令如下。 12§ netstat -nat I grep 12200 -c10 通过这个命令可以知道已经有10台机器在压测服务器。QPS达到了1400,程序开始报 错获取不到数据库连接，因为我们的数据库端口是3306,用netstat命令查看已经使用了多少 个数据库连接。命令如下。 12§ netstat -nat I grep 3306 -c12 增加数据库连接到20,QPS没上去，但是响应时长从平均1000毫秒下降到700毫秒， 使用TOP命令观察CPU利用率，发现已经90%了，于是升级CPU,将2核升级成4核， 和线上的机器保持一致。再进行压测，CPU利用率下去了达到了75%，PS上升到了1800。 执行一段时间后响应时长稳定在200毫秒。 增加应用服务器里线程池的核心线程数和最大线程数到1024,通过ps命令查看下线程 数是否增长了，执行的命令如下。 12§ ps -eLf I grep java -c1520 再次压测，QPS并没有明显的增长，单机QPS稳定在1800左右，响应时长稳定在200 毫秒。 我在性能测试之前先优化了程序的SQL语句。使用了如下命令统计执行最慢的SQL, 左边的是执行时长，单位是毫秒，右边的是执行的语句，可以看到系统执行最慢的SQL是 queryNews和queryNewlds,优化到几十毫秒。 1234567§grep Y /home/admin/logs/xxx/monitor/dal-rw-monitor.log lawk -F&#x27;,&#123;print §7§5)sort -nrlhead -201811 queryNews1764 queryNews1740 queryNews1697 queryNews679 queryNewIds 性能测试中使用的其他命令 查看网络流量。 查看系统平均负载。 查看系统内存情况。 查看CPU的利用率。 11.4异步任务池Java中的线程池设计得非常巧妙，可以高效并发执行多个任务，但是在某些场景下需 要对线程池进行扩展才能更好地服务于系统。例如，如果一个任务仍进线程池之后，运行线 程池的程序重启了，那么线程池里的任务就会丢失。另外，线程池只能处理本机的任务，在 集群环境下不能有效地调度所有机器的任务。所以，需要结合线程池开发一个异步任务处理池。图11-2为异步任务池设计图。 任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池， 当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据中，然后某台机器 上的任务池会从数据库中获取待执行的任务，再执行这个任务。 每个任务有几种状态，分别是创建(NEW)、执行中(EXECUTING)、RETRY(重试)、 挂起(SUSPEND)、中止(TEMINER)和执行完成(FINISH)。 □创建：提交给任务池之后的状态。 执行中：任务池从数据库中拿到任务执行时的状态。 重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下 一次执行时间。 挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息 后，再开始执行。 中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。 执行完成：任务执行结束。 任务池的任务隔离。异步任务有很多种类型，比如抓取网页任务、同步数据任务等，不 同类型的任务优先级不一样，但是系统资源是有限的，如果低优先级的任务非常多，高优先 级的任务就可能得不到执行，所以必须对任务进行隔离执行。使用不同的线程池处理不同的 任务，或者不同的线程池处理不同优先级的任务，如果任务类型非常少，建议用任务类型来 隔离，如果任务类型非常多，比如几十个，建议采用优先级的方式来隔离。 任务池的重试策略。根据不同的任务类型设置不同的重试策略，有的任务对实时性要求高，那么每次的重试间隔就会非常短，如果对实时性要求不高，可以采用默认的重试策略， 重试间隔随着次数的增加，时间不断增长，比如间隔几秒、几分钟到几小时。每个任务类型 可以设置执行该任务类型线程池的最小和最大线程数、最大重试次数。 使用任务池的注意事项。任务必须无状态：任务不能在执行任务的机器中保存数据，比如 某个任务是处理上传的文件，任务的属性里有文件的上传路径，如果文件上传到机器1,机器 2获取到了任务则会处理失败，所以上传的文件必须存在其他的集群里，比如OSS或SFTP。 异步任务的属性。包括任务名称、下次执行时间、已执行次数、任务类型、任务优先级 和执行时的报错信息(用于快速定位问题)。 11.5 本章小结本章介绍了使用生产者和消费者模式进行并发编程、线上问题排查手段和性能测试实战，以及异步任务池的设计。并发编程的实战需要大家平时多使用和测试，才能在项目中发挥作用"},{"title":"使用Hexo和Stellar搭建个人博客网站","path":"/2024/12/05/使用Hexo和Stellar搭建个人博客网站/","content":"安装 Git Windows：下载并安装 git。 Mac：使用 Homebrew, MacPorts 或者下载 安装程序。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装 Node.jsNode.js 为大多数平台提供了官方的 安装程序。 其它的安装方法： Windows：通过 nvs（推荐）或者 nvm 安装。 Mac：使用 Homebrew 或 MacPorts 安装。 Linux（DEB&#x2F;RPM-based）：从 NodeSource 安装。 其它：使用相应的软件包管理器进行安装。 可以参考由 Node.js 提供的 指导。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。 1$ npm install hexo"},{"title":"Hello World","path":"/2024/12/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]