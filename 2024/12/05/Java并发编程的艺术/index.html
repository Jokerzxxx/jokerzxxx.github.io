
<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>Java并发编程的艺术 - 学习记录</title>

  
    <meta name="description" content="Java并发编程的艺术第1章 并发编程的挑战1.1上下文切换CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 测试上下文切换次数和时长使用Lmbench3°可以测量上下文切换的时长。 使用vmstat可以测量上下文切换的次数。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程的艺术">
<meta property="og:url" content="http://example.com/2024/12/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/index.html">
<meta property="og:site_name" content="学习记录">
<meta property="og:description" content="Java并发编程的艺术第1章 并发编程的挑战1.1上下文切换CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 测试上下文切换次数和时长使用Lmbench3°可以测量上下文切换的时长。 使用vmstat可以测量上下文切换的次数。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230502221207154.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230502223144311.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230502223617273.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230502223646185.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230502223711761.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230502223745695.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230510201806297.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230510201926254.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230502223945615.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230510202048383.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230510204036260.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230510204131457.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230511165054511.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230511170145275.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230511170803538.png">
<meta property="og:image" content="c:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230511170817436.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230511171747731.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230511173007960.png">
<meta property="og:image" content="c:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230511173024400.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230511173045513.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230511173141630.png">
<meta property="og:image" content="c:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230511173338410.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517083730763.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517084155367.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517084223726.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517084334655.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517084609849.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517084620798.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517084849197.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517084906164.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517085010879.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517085231615.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517085342896.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517085357168.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517085501833.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517085832162.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517085848612.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517090021071.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517090033005.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517090116601.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230517090243435.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230518171006712.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516230151836.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516230232438.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516230241494.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516230608587.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516231023189.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516231147031.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516231328741.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230516231341891.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514170122957.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514170147555.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514170509410.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514170518198.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514171028604.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514171040884.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514172136970.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514172155138.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514173056584.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514173127909.png">
<meta property="og:image" content="c:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230514173257930.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514173726048.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514163230027.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514163349384.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514163614707.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514163727947.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514163747686.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514163808443.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514164559376.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230514164630022.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190546423.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190633382.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190713558.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190335110.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190402777.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190415122.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190028401.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190106592.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190124219.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190136941.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190154239.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617190210074.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185600944.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185614756.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185642620.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185705927.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185723423.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185757002.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185813512.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185427125.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185452468.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185508121.png">
<meta property="og:image" content="http://example.com/javaconcurrent.img/image-20230617185523273.png">
<meta property="og:image" content="http://example.com/jvm.img/image-20230617184611537.png">
<meta property="article:published_time" content="2024-12-05T02:10:31.000Z">
<meta property="article:modified_time" content="2024-12-05T03:29:33.297Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/javaconcurrent.img/image-20230502221207154.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">学习记录</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="探索" href="/explore/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="社交" href="/friends/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">Recent Update</span></div><div class="widget-body fs14"><a class="item title" href="/2025/03/12/%E8%80%81%E5%A7%9A%E5%90%89%E4%BB%96%E4%BB%8E%E9%9B%B6%E8%B5%B7%E6%AD%A5%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/"><span class="title">老姚吉他从零起步基础教学</span></a><a class="item title" href="/2024/12/05/Android-Studio/"><span class="title">Android Studio</span></a><a class="item title" href="/2024/12/17/Android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="title">Android编程权威指南</span></a><a class="item title" href="/2024/12/28/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/"><span class="title">第一行代码</span></a><a class="item title" href="/2024/12/12/Kotlin%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="title">Kotlin编程权威指南</span></a><a class="item title" href="/2024/12/05/can-protocol/"><span class="title">CAN协议</span></a><a class="item title" href="/2024/12/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"><span class="title">Java并发编程的艺术</span></a><a class="item title" href="/2024/12/05/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CStellar%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"><span class="title">使用Hexo和Stellar搭建个人博客网站</span></a><a class="item title" href="/2024/12/05/hello-world/"><span class="title">Hello World</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/Jokerzxxx?tab=repositories" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/github.svg"/></a><a class="social" href="https://www.nowcoder.com/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/nowcoder.svg"/></a><a class="social" href="https://leetcode.cn/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/leetcode.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/moon.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2024-12-05T02:10:31.000Z">2024-12-05</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2024-12-05T03:29:33.297Z">2024-12-05</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Java并发编程的艺术</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="Java并发编程的艺术"><a href="#Java并发编程的艺术" class="headerlink" title="Java并发编程的艺术"></a>Java并发编程的艺术</h1><h2 id="第1章-并发编程的挑战"><a href="#第1章-并发编程的挑战" class="headerlink" title="第1章 并发编程的挑战"></a>第1章 并发编程的挑战</h2><h3 id="1-1上下文切换"><a href="#1-1上下文切换" class="headerlink" title="1.1上下文切换"></a>1.1上下文切换</h3><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换。</strong></p>
<h4 id="测试上下文切换次数和时长"><a href="#测试上下文切换次数和时长" class="headerlink" title="测试上下文切换次数和时长"></a>测试上下文切换次数和时长</h4><p>使用Lmbench3°可以测量上下文切换的时长。</p>
<p>使用vmstat可以测量上下文切换的次数。</p>
<p>下面是利用vmstat测量上下文切换次数的示例。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230502221207154.png" alt="image-20230502221207154"></p>
<p>S(Content Switch)表示上下文切换的次数，从上面的测试结果中我们可以看到，上下</p>
<p>文每1秒切换1000多次。</p>
<h4 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h4><h5 id="无锁并发编程"><a href="#无锁并发编程" class="headerlink" title="无锁并发编程"></a><strong>无锁并发编程</strong></h5><p>多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</p>
<h5 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a><strong>CAS算法</strong></h5><p>Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</p>
<h5 id="使用最少线程"><a href="#使用最少线程" class="headerlink" title="使用最少线程"></a><strong>使用最少线程</strong></h5><p>避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</p>
<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a><strong>协程</strong></h5><p>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
<h4 id="减少上下文切换实战"><a href="#减少上下文切换实战" class="headerlink" title="减少上下文切换实战"></a>减少上下文切换实战</h4><p>本节将通过减少线上大量WAITING的线程，来减少上下文切换次数。</p>
<p><strong>第一步：</strong>用jstack命令dump线程信息，看看pid为3117的进程里的线程都在做什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/ifeve/java/bin/jstack 31177 &gt;/home/tengfei.fangtf/dump17</span><br></pre></td></tr></table></figure>

<p><strong>第二步：</strong>统计所有线程分别处于什么状态，发现300多个线程处于WAITING(onobjectmonitor)状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[tengfei,fangtfeifeve ～1§ grep java.lang.Thread.State dump17 I awk &#x27;(print $2§3§4§5)&#x27;I sort I uniq -c</span><br><span class="line">39 RUNNABLE</span><br><span class="line">21 TIMED_WAITING(onobjectmonitor)</span><br><span class="line">6 TIMED_WAITING(parking)</span><br><span class="line">51 TIMED_WAITING(sleeping)</span><br><span class="line">305 WAITING(onobjectmonitor)</span><br><span class="line">3 WAITING(parking)</span><br></pre></td></tr></table></figure>

<p><strong>第三步：</strong>打开dump文件查看处于WAITING(onobjectmonitor)的线程在做什么。发现这些线程基本全是JBOSS的工作线程，在await。说明JBOSS线程池里线程接收到的任务太少，大量线程都闲着。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;http-0.0.0.0-7001-97&quot;daemon prio=10 tid=0x000000004f6a8000 nid=0x555e in</span><br><span class="line">Object.wait()[0x0000000052423000]</span><br><span class="line">java.lang.Thread.State: WAITING(on object monitor)</span><br><span class="line">at java.lang.Object.wait (Native Method)</span><br><span class="line">-waiting on &lt;0x00000007969b2280&gt;(a org.apache.tomcat.util.net.AprEndpointSWorker)</span><br><span class="line">at java.lang.Object.wait(Object.java:485)</span><br><span class="line">at org.apache.tomcat.util.net.AprEndpointWorker,await (AprEndpoint.java:1464)</span><br><span class="line">-locked&lt;0x00000007969b2280&gt;(a org.apache.tomcat.util.net.AprEndpointSWorker)</span><br><span class="line">at org.apache.tomcat.util.net.AprEndpoint$Worker.run(AprEndpoint.java:1489)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>第四步：</strong>减少JBOSS的工作线程数，找到JBOSS的线程池配置信息，将maxThreads降到100。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;maxThreads=&quot;250&quot; maxHttpHeaderSize=&quot;8192&quot;</span><br><span class="line">emptySessionPath=&quot;false&quot; minSpareThreads=&quot;40&quot; maxSpareThreads=&quot;75&quot;</span><br><span class="line">maxPostSize=&quot;512000&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;200&quot; buffersize=&quot;16384&quot;</span><br><span class="line">connectionTimeout=&quot;15000&quot;disableUploadTimeout=&quot;false&quot; useBodyEncodingForURI=&quot;true&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>第五步：</strong>重启JBOSS,再dump线程信息，然后统计WAITING(onobjectmonitor)的线程，发现减少了175个。WAITING的线程少了，系统上下文切换的次数就会少，因为每一次从WAITTING到RUNNABLE都会进行一次上下文的切换。读者也可以使用vmstat命令测试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[tengfei.fangtfeifeve ～]§ grep java.lang.Thread.State dump17 I awk &#x27;(print $293§4§5)* I sort Iuniq -c</span><br><span class="line">44 RUNNABLE</span><br><span class="line">22 TIMED_WAITING(onobjectmonitor)</span><br><span class="line">9 TIMED_WAITING(parking)</span><br><span class="line">36 TIMED_WAITING(sleeping)</span><br><span class="line">130 WAITING(onobjectmonitor)</span><br><span class="line">1 WAITING(parking)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="1-2死锁"><a href="#1-2死锁" class="headerlink" title="1.2死锁"></a>1.2死锁</h3><p>免死锁的几个常见方法。</p>
<ul>
<li><p>避免一个线程同时获取多个锁。</p>
</li>
<li><p>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</p>
</li>
<li><p>尝试使用定时锁，使用lock.tryLock (timeout)来替代使用内部锁机制。</p>
</li>
<li><p>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</p>
</li>
</ul>
<h3 id="1-3资源限制的挑战"><a href="#1-3资源限制的挑战" class="headerlink" title="1.3资源限制的挑战"></a>1.3资源限制的挑战</h3><p>1.什么是资源限制</p>
<p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。</p>
<p>2.源限制引发的问题</p>
<p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅 不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</p>
<p>3.如何解决资源限制的问题</p>
<p>对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。</p>
<p>4.在资源限制情况下进行并发编程</p>
<p>如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度。</p>
<h2 id="第2章-Java并发机制的底层实现"><a href="#第2章-Java并发机制的底层实现" class="headerlink" title="第2章 Java并发机制的底层实现"></a>第2章 Java并发机制的底层实现</h2><h3 id="2-1-volatile的应用"><a href="#2-1-volatile的应用" class="headerlink" title="2.1 volatile的应用"></a>2.1 volatile的应用</h3><p>可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
<p><strong>volatile的定义与实现原理</strong></p>
<p>Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。 Java语言提供了volatile,在某些情况下比锁要更加方便。如果一个字段被声明成volatile, Java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p><strong>其实现原理相关的CPU术语与说明。</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230502223144311.png" alt="image-20230502223144311"></p>
<p>volatile是如何来保证可见性的呢?</p>
<p>让我们在X86处理器下通过工具获取JIT编译器生 成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton(); //instance是volatile变量</span><br></pre></td></tr></table></figure>

<p>转变成汇编代码，如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0×01a3deld: movb $0×0,0×1104800(%esi);0x01a3de24:lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure>

<p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32 架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情。</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内 部缓存(L1,L2或其他)后再进行操作，但操作完不知道何时会写到内存。如果对声明了 volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所 在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧 的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性协议</strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的 值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数 据读到处理器缓存里。</p>
<p>下面来具体讲解volatile的两条实现原则。</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存。</li>
</ol>
<p>Lock前缀指令导致在执行指令期间， 声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理 器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是锁 缓存，毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对 于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目 前的处理器中，<strong>如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相 反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子 性，此操作被称为“缓存锁定”</strong>,缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</p>
<ol start="2">
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</li>
</ol>
<p>IA-32处理器和Intel 64处理器使用MESI(修改、独占、共享、无效)控制协议去维护内部缓存和其他处理器缓 存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理 器访问系统内存和它们的内部缓存。<strong>处理器使用嗅探技术保证它的内部缓存、系统内存和其 他处理器的缓存的数据在总线上保持一致。</strong>例如，在Pentium和P6 family处理器中，如果 通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那 么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</p>
<p><strong>volatile的使用优化</strong></p>
<p>著名的Java并发编程大师Doug lea在JDK7的并发包里新增一个队列集合类LinkedTransferQueue,它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性 能。LinkedTransferQueue的代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**队列中的头部节点*/</span><br><span class="line">private transient final PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line">/**队列中的尾部节点*/</span><br><span class="line">private transient final PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line">static final class PaddedAtomicReference &lt;T&gt; extends AtomicReference &lt;T&gt;(</span><br><span class="line">1使用很多4个字节的引用追加到64个字节</span><br><span class="line">Object p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe;</span><br><span class="line">PaddedAtomicReference(T r)&#123;</span><br><span class="line">super(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AtomicReference &lt;V&gt; implements java.io.Serializable(</span><br><span class="line">private volatile V value;</span><br><span class="line">//省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>追加字节能优化性能?</strong></p>
<p>这种方式看起来很神奇，但如果深入理解处理器架构就能理解 其中的奥秘。让我们先来看看LinkedTransferQueue这个类，它使用一个内部类类型来定义 队列的头节点(head)和尾节点(tail),而这个内部类PaddedAtomicReference相对于父类 AtomicReference只做了一件事情，就是将共享变量追加到64字节。我们可以来计算下，一 个对象的引用占4个字节，它追加了15个变量(共占60个字节),再加上父类的value变量， 一共64个字节。</p>
<p><strong>为什么追加64字节能够提高并发编程的效率呢?</strong></p>
<p>因为对于英特尔酷睿i7、酷睿、Atom 和NetBurst,以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个 字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的 话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的 头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机 制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操 作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和 出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾 节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。 </p>
<p>那么是不是在使用volatile变量时都应该追加到64字节呢?</p>
<p>不是的。在两种场景下不应 该使用这种方式。 </p>
<p><strong>缓存行非64字节宽的处理器。</strong>如P6系列和奔腾处理器，它们的L1和L2高速缓存 行是32个字节宽。 </p>
<p><strong>共享变量不会被频繁地写。</strong>因为使用追加字节的方式需要处理器读取更多的字节到高 速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几 率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p>
<h3 id="2-2-synchronized的实现原理与应用"><a href="#2-2-synchronized的实现原理与应用" class="headerlink" title="2.2 synchronized的实现原理与应用"></a>2.2 synchronized的实现原理与应用</h3><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
<ul>
<li><p>对于普通同步方法，锁是当前实例对象。</p>
</li>
<li><p>对于静态同步方法，锁是当前类的Class对象。</p>
</li>
<li><p>对于同步方法块，锁是Synchonized括号里配置的对象。</p>
</li>
</ul>
<p>从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出 Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在 JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。 monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何 对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<h4 id="2-2-1-Java对象头"><a href="#2-2-1-Java对象头" class="headerlink" title="2.2.1 Java对象头"></a>2.2.1 Java对象头</h4><p>synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230502223617273.png" alt="image-20230502223617273"></p>
<p>Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如表2-3所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230502223646185.png" alt="image-20230502223646185"></p>
<p>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据，如表2-4所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230502223711761.png" alt="image-20230502223711761"></p>
<p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如表2-5所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230502223745695.png" alt="image-20230502223745695"></p>
<h4 id="2-2-2锁的升级与对比"><a href="#2-2-2锁的升级与对比" class="headerlink" title="2.2.2锁的升级与对比"></a>2.2.2锁的升级与对比</h4><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”,在Java SE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、 轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p>
<ol>
<li><strong>偏向锁</strong></li>
</ol>
<p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>当一个线程访问同步块 并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID,以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里 是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败， 则需要再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁):如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。	</p>
<ul>
<li>偏向锁的撤销</li>
</ul>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有 正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活 着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新 偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 图2-1中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230510201806297.png" alt="image-20230510201806297"></p>
<ul>
<li>关闭偏向锁</li>
</ul>
<p>偏向锁在Java6和Java7里是默认启用的，但是它在应用程序启动几秒钟之后才激 活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay&#x3D;0。如果你 确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false,那么程序默认会进入轻量级锁状态。</p>
<ol start="2">
<li><p><strong>轻量级锁</strong></p>
</li>
<li><p>轻量级锁加锁</p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
</li>
<li><p>轻量级锁解锁</p>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
<p>图2-2是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230510201926254.png"></p>
</li>
</ol>
<p>因为自旋会消耗CPU,为了避免无用的自旋(比如获得锁的线程被阻塞住了),一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<ol start="3">
<li><strong>锁的优缺点对比</strong></li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230502223945615.png" alt="image-20230502223945615"></p>
<h4 id="2-3原子操作的实现原理"><a href="#2-3原子操作的实现原理" class="headerlink" title="2.3原子操作的实现原理"></a>2.3原子操作的实现原理</h4><p>原子(atomic)本意是“不能被进一步分割的最小粒子”,而原子操作(atomic operation) 意为“不可被中断的一个或一系列操作”。</p>
<ol>
<li><strong>术语定义</strong></li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230510202048383.png" alt="image-20230510202048383"></p>
<ol start="2">
<li><strong>处理器如何实现原子操作</strong></li>
</ol>
<ul>
<li>使用总线锁保证原子性</li>
</ul>
<p>所谓总线锁就是使用处理器提供的一个 LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么 该处理器可以独占共享内存。</p>
<ul>
<li>使用缓存锁保证原子性</li>
</ul>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直 接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使 用“缓存锁定”的方式来实现复杂的原子性。</p>
<ol start="3">
<li>Java如何实现原子操作</li>
</ol>
<ul>
<li>使用循环CAS实现原子操作</li>
</ul>
<p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现 的基本思路就是循环进行CAS操作直到成功为止。</p>
<ul>
<li><p>CAS实现原子操作的三大问题</p>
<ul>
<li>ABA问题。</li>
</ul>
<p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没 有发生变化则更新，但是如果一个值原来是A,变成了B,又变成了A,那么使用CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p><strong>ABA问题的解决思路 就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1,那么 A→B→A就会变成1A→2B→3A。</strong></p>
<p>Java 1.5开始，JDK的Atomic包里提供了一个类 AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检 查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以 原子方式将该引用和该标志的值设置为给定的更新值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSet(</span><br><span class="line">V expectedReference,</span><br><span class="line">V newReference,</span><br><span class="line">int eptedStamp,</span><br><span class="line">int newStamp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>循环时间长开销大。</li>
</ul>
<p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开 销。</p>
<ul>
<li>只能保证一个共享变量的原子操作。</li>
</ul>
<p>当对一个共享变量执行操作时，我们可以使用 循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作 的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共 享变量来操作。</p>
<p>比如，有两个共享变量i&#x3D;2j&#x3D;a,合并一下ij&#x3D;2a,然后用CAS来操作ij。 从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把 多个变量放在一个对象里来进行CAS操作。</p>
<p>使用锁机制实现原子操作</p>
<p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循 环CAS,即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步 块的时候使用循环CAS释放锁。</p>
</li>
</ul>
<h2 id="第3章-Java内存模型"><a href="#第3章-Java内存模型" class="headerlink" title="第3章 Java内存模型"></a>第3章 Java内存模型</h2><h3 id="3-1-Java内存模型的基础"><a href="#3-1-Java内存模型的基础" class="headerlink" title="3.1 Java内存模型的基础"></a>3.1 Java内存模型的基础</h3><h4 id="3-1-1-并发编程模型的两个关键问题"><a href="#3-1-1-并发编程模型的两个关键问题" class="headerlink" title="3.1.1 并发编程模型的两个关键问题"></a>3.1.1 并发编程模型的两个关键问题</h4><p>在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步(这里 的线程是指并发执行的活动实体)。通信是指线程之间以何种机制来交换信息。</p>
<p>在命令式编程中，线程之间的通信机制有两种：<strong>共享内存和消息传递。</strong></p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状 态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发 送消息来显式进行通信。</p>
<p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型 里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执 行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p> Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h4 id="3-1-2-Java内存模型的抽象结构"><a href="#3-1-2-Java内存模型的抽象结构" class="headerlink" title="3.1.2 Java内存模型的抽象结构"></a>3.1.2 Java内存模型的抽象结构</h4><p>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间 共享(本章用“共享变量”这个术语代指实例域，静态域和数组元素)。局部变量(Local Variables),方法定义参数(Java语言规范称之为Formal Method Parameters)和异常处理器参 数(Exception Handler Parameters)不会在线程之间共享，它们不会有内存可见性问题，也不 受内存模型的影响。</p>
<p>Java线程之间的通信由Java内存模型(本文简称为JMM)控制，JMM决定一个线程对 共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间 的抽象关系：<strong>线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私 有的本地内存(Local Memory),本地内存中存储了该线程以读&#x2F;写共享变量的副本。</strong>本地内 存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的 硬件和编译器优化。</p>
<p>Java内存模型的抽象示意如图3-1所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230510204036260.png" alt="image-20230510204036260"></p>
<p>从图3-1来看，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。</p>
<ol>
<li>线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图(见图3-2)来说明这两个步骤。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230510204131457.png" alt="image-20230510204131457"></p>
<p>如图3-2所示，本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时， 这3个内存中的x值都为0。线程A在执行时，把更新后的x值(假设值为1)临时存放在 自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修 改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读 取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必 须要经过主内存。</p>
<p><strong>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序 员提供内存可见性保证。</strong></p>
<h4 id="3-1-3从源代码到指令序列的重排序"><a href="#3-1-3从源代码到指令序列的重排序" class="headerlink" title="3.1.3从源代码到指令序列的重排序"></a>3.1.3从源代码到指令序列的重排序</h4><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种 类型。</p>
<ol>
<li><strong>编译器优化的重排序。</strong>编译器在不改变单线程程序语义的前提下，可以重新安排语 句的执行顺序。</li>
<li><strong>指令级并行的重排序。</strong>现代处理器采用了指令级并行技术(Instruction-Level Parallelism,ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对 应机器指令的执行顺序。</li>
<li><strong>内存系统的重排序。</strong>由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看 上去可能是在乱序执行。</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图3-3 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230511165054511.png" alt="image-20230511165054511"></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多 线程程序出现内存可见性问题。</p>
<p>对于编译器，JMM的编译器重排序规则会禁止特定类型 的编译器重排序(不是所有的编译器重排序都要禁止)。</p>
<p>对于处理器重排序，JMM的处理 器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers,Intel称之为Memory Fence)指令，通过内存屏障指令来禁正特定类型的处理器 重排序。</p>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过 禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h4 id="3-1-4并发编程模型的分类"><a href="#3-1-4并发编程模型的分类" class="headerlink" title="3.1.4并发编程模型的分类"></a>3.1.4并发编程模型的分类</h4><h2 id="第4章-Java并发编程基础"><a href="#第4章-Java并发编程基础" class="headerlink" title="第4章 Java并发编程基础"></a>第4章 Java并发编程基础</h2><h3 id="4-1-线程简介"><a href="#4-1-线程简介" class="headerlink" title="4.1 线程简介"></a>4.1 线程简介</h3><h4 id="4-1-1什么是线程"><a href="#4-1-1什么是线程" class="headerlink" title="4.1.1什么是线程"></a>4.1.1什么是线程</h4><p>现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序， 操作系统就会创建一个Java进程。</p>
<p>现代操作系统调度的最小单元是线程，也叫轻量级进程 (Light Weight Process),在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆 栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>Java程序天生就是多线程程序，因为执行main(方法的是一个名称 为main的线程。下面使用JMX来查看一个普通的Java程序包含哪些线程，如代码清单4-1 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230511170145275.png" alt="image-20230511170145275"></p>
<p>可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其 他线程的同时运行。</p>
<h4 id="4-1-2-为什么要使用多线程"><a href="#4-1-2-为什么要使用多线程" class="headerlink" title="4.1.2 为什么要使用多线程"></a>4.1.2 为什么要使用多线程</h4><ol>
<li>更多的处理器核心</li>
</ol>
<p>使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>
<ol start="2">
<li>更快的响应时间</li>
</ol>
<p>使用多线程技术，即将数据一致性不强的操作派发给其他线程处理(也可以使用消息队列),如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<ol start="3">
<li>更好的编程模型</li>
</ol>
<p>Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将其多线程化。一旦开发人员建立好了模型，稍做修改总是能够方便地映射到Java提供的多线程编程模型上。</p>
<h4 id="4-1-3-线程优先级"><a href="#4-1-3-线程优先级" class="headerlink" title="4.1.3 线程优先级"></a>4.1.3 线程优先级</h4><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而<strong>线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。</strong></p>
<p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从 1～10,在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5,优 先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞 (休眠或者I&#x2F;O操作)的线程需要设置较高优先级，而偏重计算(需要较多CPU时间或者偏运 算)的线程则设置较低的优先级，确保处理器不会被独占。</p>
<p>在不同的JVM以及操作系统上， 线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定，示例如代码清单4-2 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230511170803538.png" alt="image-20230511170803538"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230511170817436.png" alt="image-20230511170817436"></p>
<p>从输出可以看到线程优先级没有生效，优先级1和优先级10的Job计数的结果非常相 近，没有明显差距。这表示程序正确性不能依赖线程的优先级高低。</p>
<p><strong>注意：</strong>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程 对于优先级的设定。笔者的环境为：Mac OS X10.10,Java版本为1.7.0_71,经过笔 者验证该环境下所有Java线程优先级均为5(通过jstack查看),对线程优先级的设 置会被忽略。另外，尝试在Ubuntu 14.04环境下运行该示例，输出结果也表示该环境 忽略了线程优先级的设置。</p>
<h4 id="4-1-4-线程的状态"><a href="#4-1-4-线程的状态" class="headerlink" title="4.1.4 线程的状态"></a>4.1.4 线程的状态</h4><p>Java线程在运行的生命周期中可能处于表4-1所示的6种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230511171747731.png" alt="image-20230511171747731"></p>
<p>下面我们使用jstack工具(可以选择打开终端，键入jstack或者到JDK安装目录的bin 目录下执行命令),尝试查看示例代码运行时的线程信息，更加深入地理解线程状态，示例如 代码清单4-3所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230511173007960.png" alt="image-20230511173007960"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230511173024400.png" alt="image-20230511173024400"></p>
<p>上述示例中使用的SleepUtils如代码清单4-4所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230511173045513.png" alt="image-20230511173045513"></p>
<p>运行该示例，打开终端或者命令提示符，键入“jps”,输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">611</span><br><span class="line">935 Jps</span><br><span class="line">929 ThreadState</span><br><span class="line">270</span><br></pre></td></tr></table></figure>

<p>可以看到运行示例对应的进程ID是929,接着再键入“jstack 929”(这里的进程ID需要 和读者自己键入jps得出的ID一致),部分输出如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BlockedThread-2线程阻塞在获取Blocked,class示例的锁上</span><br><span class="line">&quot;BlockedThread-2&quot; prio=5 tid=0x00007feacb05d000 nid=0x5d03 waiting for monitor</span><br><span class="line">entry [0x000000010fd58000]</span><br><span class="line">java.lang.Thread.State: BLOCKED(on object monitor)</span><br><span class="line">BlockedThread-1线程获取到了Blocked.class的锁</span><br><span class="line">&quot;BlockedThread-1&quot; prio=5 tid=0x00007feacb05a000 nid=0x5b03 waiting on condition</span><br><span class="line">[0x000000010fc55000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING(sleeping)</span><br><span class="line">WaitingThread线程在Waiting实例上等待</span><br><span class="line">&quot;WaitingThread&quot; prio=5 tid=0x00007feacb059800 nid=0x5903 in Object.wait()</span><br><span class="line">[0×000000010fb52000]</span><br><span class="line">java.lang.Thread.State: WAITING(on object monitor)</span><br><span class="line">TimeWaitingThread线程处于超时等待</span><br><span class="line">&quot;TimeWaitingThread&quot; prio=5 tid=0x00007feacb058800 nid=0x5703 waiting on condition</span><br><span class="line">[0x000000010fa4f0001</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING(sleeping)</span><br></pre></td></tr></table></figure>

<p>通过示例，我们了解到Java程序运行中线程状态的具体含义。线程在自身的生命周期 中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如图4-1示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230511173141630.png" alt="image-20230511173141630"></p>
<p>由图4-1中可以看到，线程创建之后，调用start()方法开始运行。当线程执行wait()方 法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运 行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达 时将会返回到运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</p>
<p><strong>注意：</strong>Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在 进入synchronized关键字修饰的方法或代码块(获取锁)时的状态，但是阻塞在java. concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock 接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
<h4 id="4-1-5-Daemon线程"><a href="#4-1-5-Daemon线程" class="headerlink" title="4.1.5 Daemon线程"></a>4.1.5 Daemon线程</h4><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。 这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以 通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>
<p><strong>注意：</strong>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。</p>
<p>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的 finally块并不一定会执行，示例如代码清单4-5所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230511173338410.png" alt="image-20230511173338410"></p>
<p>运行Daemon程序，可以看到在终端或者命令提示符上没有任何输出。main线程(非Daemon线程)在启动了线程DaemonRunner之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线 程都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没 有执行。</p>
<p><strong>注意：</strong>在构建Dacmon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h3 id="4-2启动和终止线程"><a href="#4-2启动和终止线程" class="headerlink" title="4.2启动和终止线程"></a>4.2启动和终止线程</h3><h4 id="4-2-1-构造线程"><a href="#4-2-1-构造线程" class="headerlink" title="4.2.1 构造线程"></a>4.2.1 构造线程</h4><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要 的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。代码清单4-6所 示的代码摘自java.lang.Thread中对线程进行初始化的部分。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517083730763.png" alt="image-20230517083730763"></p>
<p>在上述过程中，一个新构造的线程对象是由其parent线程来进行空间分配的，而child 线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的 ThreadLocal,同时还会分配一个唯一的ID来标识这个child线程。</p>
<h4 id="4-2-2-启动线程"><a href="#4-2-2-启动线程" class="headerlink" title="4.2.2 启动线程"></a>4.2.2 启动线程</h4><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程(即parent线程)同步告知Java虚拟机，只要线程规划器空闲，应立即启 动调用start()方法的线程。</p>
<p><strong>注意：</strong>启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。</p>
<h4 id="4-2-3-理解中断"><a href="#4-2-3-理解中断" class="headerlink" title="4.2.3 理解中断"></a>4.2.3 理解中断</h4><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行 了中断操作。</p>
<p>线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是 否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如 果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。</p>
<p>从Java的API中可以看到，许多声明抛出InterruptedException的方法(例如Thread. sleep(long millis)方法)这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException,此时调用isInterrupted()方法将会返回 false。</p>
<p>在代码清单4-7所示的例子中，首先创建了两个线程，SleepThread和BusyThread,前 者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517084155367.png" alt="image-20230517084155367"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517084223726.png" alt="image-20230517084223726"></p>
<p>从结果可以看出，抛出InterruptedException的线程SleepThread,其中断标识位被清除 了，而一直忙碌运作的线程BusyThread,中断标识位没有被清除。</p>
<h4 id="4-2-4-过期的suspend-、resume-和stop"><a href="#4-2-4-过期的suspend-、resume-和stop" class="headerlink" title="4.2.4 过期的suspend()、resume()和stop()"></a>4.2.4 过期的suspend()、resume()和stop()</h4><p>大家对于CD机肯定不会陌生，如果把它播放音乐比作一个线程的运作，那么对音乐 播放做出的暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和 stop()。</p>
<p>在代码清单4-8所示的例子中，创建了一个线程PrintThread,它以1秒的频率进行打 印，而主线程对其进行暂停、恢复和停止操作。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517084334655.png" alt="image-20230517084334655"></p>
<p>在执行过程中，PrintThread运行了3秒，随后被暂停，3秒后恢复，最后经过3秒被终止。 通过示例的输出可以看到，suspend0、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p>
<p>不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源(比如锁),而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<p><strong>注意：</strong>正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而暂停和恢复操作可以用后面提到的等待&#x2F;通知机制来替代。</p>
<h4 id="4-2-5-安全地终止线程"><a href="#4-2-5-安全地终止线程" class="headerlink" title="4.2.5 安全地终止线程"></a>4.2.5 安全地终止线程</h4><p>在4.2.3节中提到的中断状态是线程的一个标识位，而中断操作是一种简便的线程间 交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个 boolean变量来控制是否需要停止任务并终止该线程。</p>
<p>在代码清单4-9所示的例子中，创建了一个线程CountThread,它不断地进行变量累加， 而主线程尝试对其进行中断操作和停止操作。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517084609849.png" alt="image-20230517084609849"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517084620798.png" alt="image-20230517084620798"></p>
<p>输出结果如下所示(输出内容可能不同)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Count i = 543487324</span><br><span class="line">Count i = 540898082</span><br></pre></td></tr></table></figure>

<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终 止。这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p>
<h3 id="4-3线程间通信"><a href="#4-3线程间通信" class="headerlink" title="4.3线程间通信"></a>4.3线程间通信</h3><h4 id="4-3-1-volatile和synchronized关键字"><a href="#4-3-1-volatile和synchronized关键字" class="headerlink" title="4.3.1 volatile和synchronized关键字"></a>4.3.1 volatile和synchronized关键字</h4><p>关键字volatile可以用来修饰字段(成员变量),就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访 问的可见性。</p>
<p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>在代码清单4-10所示的例子中，使用了同步块和同步方法，通过使用javap工具查看生 成的class文件信息来分析synchronized关键字的实现细节，示例如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517084849197.png" alt="image-20230517084849197"></p>
<p>在Synchronized.class同级目录执行javap-v Synchronized.class,部分相关输出如下所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517084906164.png" alt="image-20230517084906164"></p>
<p>上面class信息中，对于同步块的实现使用了monitorenter和monitorexit指令，而同步 方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。无论采用哪种方式，其本 质是对一个对象的监视器(monitor)进行获取，而这个获取过程是排他的，也就是同一时刻 只能有一个线程获取到由synchronized所保护对象的监视器。</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而 没有获取到监视器(执行该方法)的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。</p>
<p>图4-2描述了对象、对象的监视器、同步队列和执行线程之间的关系</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517085010879.png" alt="image-20230517085010879"></p>
<p>从图4-2中可以看到，任意线程对Object(Object由synchronized保护)的访问，首先要 获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访 问Object的前驱(获得了锁的线程)释放了锁，则该释放操作唤醒阻塞在同步队列中的线程， 使其重新尝试对监视器的获取。</p>
<h4 id="4-3-2-等待-通知机制"><a href="#4-3-2-等待-通知机制" class="headerlink" title="4.3.2 等待&#x2F;通知机制"></a>4.3.2 等待&#x2F;通知机制</h4><p>等待&#x2F;通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超 类java.lang.Object上，方法和描述如表4-2所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517085231615.png" alt="image-20230517085231615"></p>
<p>等待&#x2F;通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait() 方法返回，进而执行后续操作。</p>
<p>在代码清单4-11所示的例子中，创建了两个线程——WaitThread和NotifyThread,前者 检查flag值是否为false,如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠 了一段时间后对lock进行通知，示例如下所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517085342896.png" alt="image-20230517085342896"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517085357168.png" alt="image-20230517085357168"></p>
<p>上述第3行和第4行输出的顺序可能会互换，而上述例子主要说明了调用wait()、 notify()以及notifyAll()时需要注意的细节，如下。</p>
<ol>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</li>
<li>调用wait()方法后，线程状态由RUNNING变为WAITING,并将当前线程放置到对 象的等待队列。</li>
<li>notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用 notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</li>
<li>notify(方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而 notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由 WAITING变为BLOCKED。</li>
<li>从wait()方法返回的前提是获得了调用对象的锁。</li>
</ol>
<p>从上述细节中可以看到，等待&#x2F;通知机制依托于同步机制，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。</p>
<p>图4-3描述了上述示例的过程。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517085501833.png" alt="image-20230517085501833"></p>
<p>在图4-3中，WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了 锁并进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁， NotifyThread随后获取了对象的锁，并调用对象的notify(方法，将WaitThread从WaitQueue 移到SynchronizedQucue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之 后，WaitThread再次获取到锁并从wait()方法返回继续执行。</p>
<h4 id="4-3-3-等待-通知的经典范式"><a href="#4-3-3-等待-通知的经典范式" class="headerlink" title="4.3.3 等待&#x2F;通知的经典范式"></a>4.3.3 等待&#x2F;通知的经典范式</h4><p>从4.3.2节中的WaitNotify示例中可以提炼出等待&#x2F;通知的经典范式，该范式分为两部分，分别针对等待方(消费者)和通知方(生产者)。</p>
<p>等待方遵循如下原则。</p>
<ol>
<li>获取对象的锁。</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ol>
<p>对应的伪代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)(</span><br><span class="line">	while(条件不满足)(</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通知方遵循如下原则。</p>
<ol>
<li>获得对象的锁。</li>
<li>改变条件。</li>
<li>通知所有等待在对象上的线程。</li>
</ol>
<p>对应的伪代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)(</span><br><span class="line">	改变条件</span><br><span class="line">	对象.notifyAl1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-管道输入-输出流"><a href="#4-3-4-管道输入-输出流" class="headerlink" title="4.3.4 管道输入&#x2F;输出流"></a>4.3.4 管道输入&#x2F;输出流</h4><p>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>管道输入&#x2F;输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter,前两种面向字节，而后两种面向字符。</p>
<p>在代码清单4-12所示的例子中，创建了printThread,它用来接受main线程的输入，任 何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517085832162.png" alt="image-20230517085832162"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517085848612.png" alt="image-20230517085848612"></p>
<p>运行该示例，输入一组字符串，可以看到被printThread进行了原样输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Repeat my words.</span><br><span class="line">Repeat my words.</span><br></pre></td></tr></table></figure>

<p>对于Piped类型的流，必须先要进行绑定，也就是调用connect(方法，如果没有将输入&#x2F; 输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h4 id="4-3-5-Thread-join-的使用"><a href="#4-3-5-Thread-join-的使用" class="headerlink" title="4.3.5 Thread.join()的使用"></a>4.3.5 Thread.join()的使用</h4><p>如果一个线程A执行了threadjoin()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis, int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线 程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p>
<p>在代码清单4-13所示的例子中，创建了10个线程，编号0～9,每个线程调用前一个 线程的join()方法，也就是线程0结束了，线程1才能从join()方法中返回，而线程0需要等待main线程结束。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517090021071.png" alt="image-20230517090021071"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517090033005.png" alt="image-20230517090033005"></p>
<p>输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main terminate.</span><br><span class="line">0 terminate.</span><br><span class="line">1 terminate.</span><br><span class="line">2 terminate.</span><br><span class="line">3 terminate.</span><br><span class="line">4 terminate.</span><br><span class="line">5 terminate.</span><br><span class="line">6 terminate.</span><br><span class="line">7 terminate.</span><br><span class="line">8 terminate.</span><br><span class="line">9 terminate.</span><br></pre></td></tr></table></figure>

<p>从上述输出可以看到，每个线程终止的前提是前驱线程的终止，每个线程等待前驱线程 终止后，才从join()方法返回，这里涉及了等待&#x2F;通知机制(等待前驱线程结束，接收前驱线程结束通知)。</p>
<p>代码清单4-14是JDK中Thread.join()方法的源码(进行了部分调整)。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517090116601.png" alt="image-20230517090116601"></p>
<p>当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的 线程。可以看到join()方法的逻辑结构与4.3.3节中描述的等待&#x2F;通知经典范式一致，即加 锁、循环和处理逻辑3个步骤。</p>
<h4 id="4-3-6-ThreadLocal的使用"><a href="#4-3-6-ThreadLocal的使用" class="headerlink" title="4.3.6 ThreadLocal的使用"></a>4.3.6 ThreadLocal的使用</h4><p>ThreadLocal,即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结 构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑 定在这个线程上的一个值。</p>
<p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
<p>在代码清单4-15所示的例子中，构建了一个常用的Profiler类，它具有begin(和end()两个 方法，而end(方法返回从begin()方法调用开始到end(方法被调用时的时间差，单位是毫秒。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230517090243435.png" alt="image-20230517090243435"></p>
<p>Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法， 在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中，比如在 AOP(面向方面编程)中，可以在方法调用前的切人点执行begin()方法，而在方法调用后的切入点执行end()方法，这样依旧可以获得方法的执行耗时。</p>
<h3 id="4-4线程应用实例"><a href="#4-4线程应用实例" class="headerlink" title="4.4线程应用实例"></a>4.4线程应用实例</h3><h4 id="4-4-1-等待超时模式"><a href="#4-4-1-等待超时模式" class="headerlink" title="4.4.1 等待超时模式"></a>4.4.1 等待超时模式</h4><p>开发人员经常会遇到这样的方法调用场景：调用一个方法时等待一段时间(一般来说是 给定一个时间段),如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</p>
<p>前面的章节介绍了等待&#x2F;通知的经典范式，即加锁、条件循环和处理逻辑3个步骤，而 这种范式无法做到超时等待。而超时等待的加入，只需要对经典范式做出非常小的改动，改动内容如下所示。</p>
<p>假设超时时间段是T,那么可以推断出在当前时间now+T之后就会超时。</p>
<p>定义如下变量。</p>
<ul>
<li>等待持续时间：REMAINING&#x3D;T。</li>
<li>超时时间：FUTURE&#x3D;now+T。</li>
</ul>
<p>这时仅需要wait(REMAINING)即可，在wait(REMAINING)返回之后会将执行： REMAINING&#x3D;FUTURE-now。如果REMAINING小于等于0,表示已经超时，直接退出， 否则将继续执行wait(REMAINING)。</p>
<p>上述描述等待超时模式的伪代码如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230518171006712.png" alt="image-20230518171006712"></p>
<p>可以看出，等待超时模式就是在等待&#x2F;通知范式基础上增加了超时控制，这使得该模式 相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而 是会按照调用者的要求“按时”返回。</p>
<h4 id="4-4-2一个简单的数据库连接池示例"><a href="#4-4-2一个简单的数据库连接池示例" class="headerlink" title="4.4.2一个简单的数据库连接池示例"></a>4.4.2一个简单的数据库连接池示例</h4><p>我们使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在 1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。设定连接池的大小为10 个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p>
<p>首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列 来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连 接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示 例如代码清单4-16所示。</p>
<h4 id="4-4-3线程池技术及其示例"><a href="#4-4-3线程池技术及其示例" class="headerlink" title="4.4.3线程池技术及其示例"></a>4.4.3线程池技术及其示例</h4><h2 id="第5章-Java中的锁"><a href="#第5章-Java中的锁" class="headerlink" title="第5章 Java中的锁"></a>第5章 Java中的锁</h2><h2 id="第6章-Java并发容器和框架"><a href="#第6章-Java并发容器和框架" class="headerlink" title="第6章 Java并发容器和框架"></a>第6章 Java并发容器和框架</h2><h2 id="第7章-Java中的13个原子操作类-√"><a href="#第7章-Java中的13个原子操作类-√" class="headerlink" title="第7章 Java中的13个原子操作类(√)"></a>第7章 Java中的13个原子操作类(√)</h2><p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包(以下简称Atomic包),这个 包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是**原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)**。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<h3 id="7-1-原子更新基本类型类"><a href="#7-1-原子更新基本类型类" class="headerlink" title="7.1 原子更新基本类型类"></a>7.1 原子更新基本类型类</h3><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p>
<ul>
<li>AtomicBoolean:原子更新布尔类型。</li>
<li>AtomicInteger:原子更新整型。</li>
<li>AtomicLong:原子更新长整型。</li>
</ul>
<p>以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下。</p>
<ul>
<li>int addAndGet(int delta):以原子方式将输入的数值与实例中的值(AtomicInteger里 的value)相加，并返回结果。</li>
<li>boolean compareAndSet(int expect,int update):如果输入的数值等于预期值，则以原 子方式将该值设置为输入的值。</li>
<li>int getAndIncrement():以原子方式将当前值加1,注意，这里返回的是自增前的值。</li>
<li>void lazySet(int newValue):最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</li>
<li>int getAndSet(int newValue):以原子方式设置为newValue的值，并返回旧值。</li>
</ul>
<p>AtomicInteger示例代码如代码清单7-1所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516230151836.png" alt="image-20230516230151836"></p>
<p>那么getAndIncrement是如何实现原子操作的呢?让我们一起分析其实现原理， getAndIncrement的源码如代码清单7-2所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516230232438.png" alt="image-20230516230232438"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516230241494.png" alt="image-20230516230241494"></p>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值，第二步对AtomicInteger 的当前数值进行加1操作，关键的第三步调用compareAndSet方法来进行原子更新操作，该 方法先检查当前数值是否等于current,等于意味着AtomicInteger的值没有被其他线程修改 过，则将AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回 false,程序会进入for循环重新进行compareAndSet操作。</p>
<p>Atomic包提供了3种基本类型的原子更新，但是Java的基本类型里还有char、float和 double等。那么问题来了，如何原子的更新其他的基本类型呢?Atomic包里的类基本都是 使用Unsafe实现的，让我们一起看一下Unsafe的源码，如代码清单7-3所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516230608587.png" alt="image-20230516230608587"></p>
<p>通过代码，我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong,再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS,所以原子更新char、float和double变量 也可以用类似的思路来实现。</p>
<h3 id="7-2-原子更新数组"><a href="#7-2-原子更新数组" class="headerlink" title="7.2 原子更新数组"></a>7.2 原子更新数组</h3><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类。</p>
<ul>
<li><p>AtomicIntegerArray:原子更新整型数组里的元素。</p>
</li>
<li><p>AtomicLongArray:原子更新长整型数组里的元素。</p>
</li>
<li><p>AtomicReferenceArray:原子更新引用类型数组里的元素。 </p>
</li>
<li><p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下。</p>
<ul>
<li><p>int addAndGet(inti,int delta):以原子方式将输入值与数组中索引i的元素相加。</p>
</li>
<li><p>boolean compareAndSet(int i, int expect, int update):如果当前值等于预期值，则 以原子方式将数组位置i的元素设置成update值。</p>
<p>以上几个类提供的方法几乎一样，所以本节仅以AtomicIntegerArray为例进行讲解， AtomicIntegerArray的使用实例代码如代码清单7-4所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516231023189.png" alt="image-20230516231023189"></p>
<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前 数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的 数组。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-3-原子更新引用类型"><a href="#7-3-原子更新引用类型" class="headerlink" title="7.3 原子更新引用类型"></a>7.3 原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger,只能更新一个变量，如果要原子更新多个变量，就 需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<ul>
<li>AtomicReference:原子更新引用类型。 </li>
<li>AtomicReferenceFieldUpdater:原子更新引用类型里的字段。 </li>
<li>AtomicMarkableReference:原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef, boolean initialMark)。</li>
</ul>
<p>以上几个类提供的方法几乎一样，所以本节仅以AtomicReference为例进行讲解， AtomicReference的使用示例代码如代码清单7-5所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516231147031.png" alt="image-20230516231147031"></p>
<p>代码中首先构建一个user对象，然后把user对象设置进AtomicReferenc中，最后调用 compareAndSet方法进行原子更新操作，实现原理同AtomicInteger里的compareAndSet方 法。代码执行后输出结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shinichi </span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<h3 id="7-4-原子更新字段类"><a href="#7-4-原子更新字段类" class="headerlink" title="7.4 原子更新字段类"></a>7.4 原子更新字段类</h3><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供 了以下3个类进行原子字段更新。</p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater:原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference:原子更新带有版本号的引用类型。该类将整数值与引用关 联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</li>
</ul>
<p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段(属性)必须使用public volatile修饰符。</p>
<p>以上3个类提供的方法几乎一样，所以本节仅以AstomicIntegerFieldUpdater为例进行讲解，AstomicIntegerFieldUpdater的示例代码如代码清单7-6所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516231328741.png" alt="image-20230516231328741"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230516231341891.png" alt="image-20230516231341891"></p>
<h2 id="第8章-Java中的并发工具类"><a href="#第8章-Java中的并发工具类" class="headerlink" title="第8章 Java中的并发工具类"></a>第8章 Java中的并发工具类</h2><p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier 和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间 交换数据的一种手段。</p>
<h3 id="8-1等待多线程完成的CountDownLatch"><a href="#8-1等待多线程完成的CountDownLatch" class="headerlink" title="8.1等待多线程完成的CountDownLatch"></a>8.1等待多线程完成的CountDownLatch</h3><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<p>假如有这样一个需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使 用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提 示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的 做法是使用join()方法，如代码清单8-1所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514170122957.png" alt="image-20230514170122957"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514170147555.png"></p>
<p>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否 存活，如果join线程存活则让当前线程永远等待。其中，wait(0)表示永远等待下去，代码 片段如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (isAlive())&#123;</span><br><span class="line">wait(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在 JVM里实现的，所以在JDK里看不到，大家可以查看JVM源码。</p>
<p>在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比 join的功能更多，如代码清单8-2所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514170509410.png" alt="image-20230514170509410"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514170518198.png" alt="image-20230514170518198"></p>
<p>CountDownLatch的构造函数接收一个int类型的参数</p>
<p>作为计数器，如果你想等待N个点 完成，这里就传入N。</p>
<p>当我们调用CountDownLatch的countDown方法时，N就会减1,CountDownLatch的 await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以 这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程 时，只需要把这个CountDownLatch的引用传递到线程里即可。</p>
<p>如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以 使用另外一个带指定时间的await方法——await(long time,TimeUnit unit),这个方法等待 特定时间后，就会不再阻塞当前线程。join也有类似的方法。</p>
<p><strong>注意：</strong>计数器必须大于等于0,只是等于0时候，计数器就是零，调用await方法时不会阻 塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的 内部计数器的值。一个线程调用countDown方法happen-before,另外一个线程调用 await方法。</p>
<h3 id="8-2同步屏障CyclicBarrier"><a href="#8-2同步屏障CyclicBarrier" class="headerlink" title="8.2同步屏障CyclicBarrier"></a>8.2同步屏障CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做的事情是，让 一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障 才会开门，所有被屏障拦截的线程才会继续运行。</p>
<h4 id="8-2-1-CyclicBarrier简介"><a href="#8-2-1-CyclicBarrier简介" class="headerlink" title="8.2.1 CyclicBarrier简介"></a>8.2.1 CyclicBarrier简介</h4><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties),其参数表示屏障拦截的线程 数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。 示例代码如代码清单8-3所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514171028604.png" alt="image-20230514171028604"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514171040884.png" alt="image-20230514171040884"></p>
<p>因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生 两种输出，第一种可能输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>第二种可能输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>如果把new CyclicBarrier(2)修改成new CyclicBarrier(3),则主线程和子线程会永远等 待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障 的两个线程都不会继续执行。</p>
<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties,Runnable barrierAction),用于在线程到达屏障时，优先执行barrierAction,方便处理更复杂的业务场景，如 代码清单8-4所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514172136970.png" alt="image-20230514172136970"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514172155138.png" alt="image-20230514172155138"></p>
<p>因为CyclicBarrier设置了拦截线程的数量是2,所以必须等代码中的第一个线程和线程 A都执行完之后，才会继续执行主线程，然后输出2,所以代码执行后的输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="8-2-2-CyclicBarrier的应用场"><a href="#8-2-2-CyclicBarrier的应用场" class="headerlink" title="8.2.2 CyclicBarrier的应用场"></a>8.2.2 CyclicBarrier的应用场</h4><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p>
<p>例如，用一个Excel 保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计 用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个 sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel 的日均银行流水，如代码清单8-5所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514173056584.png" alt="image-20230514173056584"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514173127909.png"></p>
<p>使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1,再 由BankWaterService线程汇总4个sheet计算出的结果，输出结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-CyclicBarrier和CountDownLatch的区别"><a href="#8-2-3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="8.2.3 CyclicBarrier和CountDownLatch的区别"></a>8.2.3 CyclicBarrier和CountDownLatch的区别</h4><p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</strong>所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p>
<p>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。代码清单8-5执 行完之后会返回true,其中isBroken的使用代码如代码清单8-6所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:/Users/Jokerz/AppData/Roaming/Typora/typora-user-images/image-20230514173257930.png" alt="image-20230514173257930"></p>
<h4 id="8-3控制并发线程数的Semaphore"><a href="#8-3控制并发线程数的Semaphore" class="headerlink" title="8.3控制并发线程数的Semaphore"></a>8.3控制并发线程数的Semaphore</h4><p><strong>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程， 以保证合理的使用公共资源。</strong></p>
<p>1.应用场景</p>
<p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十 个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有 10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获 取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如代码清单8-7所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514173726048.png" alt="image-20230514173726048"></p>
<p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方 法Semaphore(int permits)接受一个整型的数字，表示可用的许可证数量。Semaphore(10) 表示允许10个线程获取许可证，也就是最大并发数是10。</p>
<p><strong>Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还 许可证。还可以用tryAcquire()方法尝试获取许可证。</strong></p>
<p>2.其他方法</p>
<pre><code>- intavailablePermits():返回此信号量中当前可用的许可证数。
- intgetQueueLength():返回正在等待获取许可证的线程数。
-  booleanhasQueuedThreads():是否有线程正在等待获取许可证。
-  void reducePermits(int reduction):减少reduction个许可证，是个protected方法。 
- Collection getQueuedThreads():返回所有等待获取许可证的线程集合，是个protected 方法。
</code></pre>
<h4 id="8-4线程间交换数据的Exchanger"><a href="#8-4线程间交换数据的Exchanger" class="headerlink" title="8.4线程间交换数据的Exchanger"></a>8.4线程间交换数据的Exchanger</h4><p>Exchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数 据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通 过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线 程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线 程生产出来的数据传递给对方。</p>
<h2 id="第9章-Java中的线程池"><a href="#第9章-Java中的线程池" class="headerlink" title="第9章 Java中的线程池"></a>第9章 Java中的线程池</h2><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。</p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资 源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ol>
<h3 id="9-1线程池的实现原理"><a href="#9-1线程池的实现原理" class="headerlink" title="9.1线程池的实现原理"></a>9.1线程池的实现原理</h3><p>当向线程池提交一个任务之后，线程池是如何处理这个任务的呢? 处理流程图如图9-1所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514163230027.png" alt="image-20230514163230027"></p>
<p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。</p>
<ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工 作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在 这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线 程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p>ThreadPoolExecutor执行execute()方法的示意图，如图9-2所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514163349384.png" alt="image-20230514163349384"></p>
<p>ThreadPoolExecutor执行execute方法分下面4种情况。</p>
<ol>
<li>如果当前运行的线程少于corePoolSize,则创建新线程来执行任务(注意，执行这一 步骤需要获取全局锁)。</li>
<li>如果运行的线程等于或多于corePoolSize,则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue(队列已满),则创建新的线程来处理任务(注意， 执行这一步骤需要获取全局锁)。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝，并调 用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽 可能地避免获取全局锁(那将会是一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热 之后(当前运行的线程数大于等于corePoolSize),几乎所有的execute()方法调用都是执行步 骤2,而步骤2不需要获取全局锁。</p>
<p><strong>源码分析：</strong>上面的流程分析让我们很直观地了解了线程池的工作原理，让我们再通过源 代码来看看是如何实现的，线程池执行任务的方法如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514163614707.png" alt="image-20230514163614707"></p>
<p><strong>工作线程：</strong>线程池创建线程时，会将线程封装成工作线程Worker,Worker在执行完任 务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到 这点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514163727947.png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514163747686.png" alt="image-20230514163747686"></p>
<p>ThreadPoolExecutor中线程执行任务的示意图如图9-3所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514163808443.png" alt="image-20230514163808443"></p>
<p>线程池中的线程执行任务分两种情况，如下。</p>
<ol>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li>
<li>这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。</li>
</ol>
<h3 id="9-2线程池的使用"><a href="#9-2线程池的使用" class="headerlink" title="9.2线程池的使用"></a>9.2线程池的使用</h3><h4 id="9-2-1线程池的创建"><a href="#9-2-1线程池的创建" class="headerlink" title="9.2.1线程池的创建"></a>9.2.1线程池的创建</h4><p>可以通过ThreadPoolExecutor来创建一个线程池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,</span><br><span class="line">milliseconds,runnableTaskQueue, handler);</span><br></pre></td></tr></table></figure>

<p>创建一个线程池时需要输入几个参数，如下。</p>
<ol>
<li>corePoolSize(线程池的基本大小):当提交一个任务到线程池时，线程池会创建一个 线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的 任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads(方 法，线程池会提前创建并启动所有基本线程。</li>
<li>runnableTaskQueue(任务队列):用于保存等待执行的任务的阻塞队列。可以选择以 下几个阻塞队列。<ul>
<li>ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先 出)原则对元素进行排序。</li>
<li>LinkedBlockingQueue:一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞 吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool() 使用了这个队列。</li>
<li>SynchronousQueue:一个不存储元素的阻塞队列。每个插入操作必须等到另一个 线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQucue,静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue:一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li>maximumPoolSize(线程池最大数量):线程池允许创建的最大线程数。如果队列满 了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意 的是，如果使用了无界的任务队列这个参数就没什么效果。</li>
<li>ThreadFactory:用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线 程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池 里的线程设置有意义的名字，代码如下。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ThreadFactoryBuilder().setNameFormat(&quot;xx-task-sd&quot;).build();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>RejectedExecutionHandler(饱和策略):当队列和线程池都满了，说明线程池处于饱 和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy,表 示无法处理新任务时抛出异常。在JDK1.5中Java线程池框架提供了以下4种策略。</p>
<ul>
<li>AbortPolicy:直接抛出异常。</li>
<li>CallerRunsPolicy:只用调用者所在线程来运行任务。 </li>
<li>DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。 </li>
<li>DiscardPolicy:不处理，丢弃掉。</li>
</ul>
<p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如 记录日志或持久化存储不能处理的任务。</p>
<ul>
<li>keepAliveTime(线程活动保持时间):线程池的工作线程空闲后，保持存活的时间。 所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的 利用率。</li>
<li>TimeUnit(线程活动保持时间的单位):可选的单位有天(DAYS)、小时(HOURS)、 分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS,千分之一毫 秒)和纳秒(NANOSECONDS,千分之一微秒)。</li>
</ul>
<h4 id="9-2-2向线程池提交任务"><a href="#9-2-2向线程池提交任务" class="headerlink" title="9.2.2向线程池提交任务"></a>9.2.2向线程池提交任务</h4><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p>
<p><strong>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</strong>通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514164559376.png" alt="image-20230514164559376"></p>
<p><strong>submit()方法用于提交需要返回值的任务</strong>。线程池会返回一个future类型的对象，通过 这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回 值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout,TimeUnit unit)方法 则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230514164630022.png" alt="image-20230514164630022"></p>
<h4 id="9-2-3关闭线程池"><a href="#9-2-3关闭线程池" class="headerlink" title="9.2.3关闭线程池"></a>9.2.3关闭线程池</h4><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断 的任务可能永远无法终止。</p>
<p>shutdownNow首先将线程池的状态设 置成STOP,然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>
<p>shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任 务的线程。</p>
<p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调 用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法 来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<h4 id="9-2-4合理地配置线程池"><a href="#9-2-4合理地配置线程池" class="headerlink" title="9.2.4合理地配置线程池"></a>9.2.4合理地配置线程池</h4><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 </li>
<li>任务的优先级：高、中和低。 </li>
<li>任务的执行时间：长、中和短。 </li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的 线程，如配置N+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则 应配置尽可能多的线程，如2*N。混合型的任务，如果可以拆分，将其拆分成一个CPU密 集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执 行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分 解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级 高的任务先执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让 执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p>
<p><strong>建议使用有界队列。</strong>有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃 任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台 任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全 部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来 越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们 的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任 务，但是出现这样问题时也会影响到其他任务。</p>
<h4 id="9-2-5线程池的监控"><a href="#9-2-5线程池的监控" class="headerlink" title="9.2.5线程池的监控"></a>9.2.5线程池的监控</h4><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以 根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池 的时候可以使用以下属性。</p>
<ul>
<li>taskCount:线程池需要执行的任务数量。 </li>
<li>completedTaskCount:线程池在运行过程中已完成的任务数量，小于或等于taskCount。 </li>
<li>largestPoolSize:线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程 池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 </li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动 销毁，所以这个大小只增不减。 </li>
<li>getActiveCount:获取活动的线程数。 通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭 前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时 间等。这几个方法在线程池里是空方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void beforeExecute(Thread t, Runnable r)()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第10章-Executor框架"><a href="#第10章-Executor框架" class="headerlink" title="第10章 Executor框架"></a>第10章 Executor框架</h2><p>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们 为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时， 为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。 </p>
<p>Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作单元与执行机制分离 开来。工作单元包括Runnable和Callable,而执行机制由Executor框架提供。</p>
<h3 id="10-1-Executor框架简介"><a href="#10-1-Executor框架简介" class="headerlink" title="10.1 Executor框架简介"></a>10.1 Executor框架简介</h3><h4 id="10-1-1-Executor框架的两级调度模型"><a href="#10-1-1-Executor框架的两级调度模型" class="headerlink" title="10.1.1 Executor框架的两级调度模型"></a>10.1.1 Executor框架的两级调度模型</h4><p>在HotSpot VM的线程模型中，Java线程(java.lang.Thread)被一对一映射为本地操作系 统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系 统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器 (Executor框架)将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射 到硬件处理器上。这种两级调度模型的示意图如图10-1所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190546423.png" alt="image-20230617190546423"></p>
<p>从图中可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系 统内核控制，下层的调度不受应用程序的控制。</p>
<h4 id="10-1-2-Executor框架的结构与成员"><a href="#10-1-2-Executor框架的结构与成员" class="headerlink" title="10.1.2 Executor框架的结构与成员"></a>10.1.2 Executor框架的结构与成员</h4><ol>
<li>Executor框架的结构</li>
</ol>
<p>Executor框架主要由3大部分组成如下。 </p>
<ul>
<li>任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。 </li>
<li>任务的执行。包括任务执行机制的核心接口Executor,以及继承自Executor的 ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口 (ThreadPoolExecutor和ScheduledThreadPoolExecutor)。 </li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。 Executor框架包含的主要的类与接口如图10-2所示。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190633382.png" alt="image-20230617190633382"></p>
<p>下面是这些类和接口的简介。 </p>
<ul>
<li>Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离 开来。 </li>
<li>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。 </li>
<li>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定 期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。 </li>
<li>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。 </li>
<li>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。</li>
</ul>
<p>Executor框架的使用示意图如图10-3所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190713558.png" alt="image-20230617190713558"></p>
<p>主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可 以把一个Runnable对象封装为一个Callable对象(Executors.callable(Runnable task)或 Executors.callable(Runnable task, Object resule))。</p>
<p>然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute (Runnable command));或者也可以把Runnable对象或Callable对象提交给ExecutorService执行(ExecutorService.submit(Runnable task)或ExecutorService.submit (Callable task))。</p>
<p>如果执行ExecutorService.submit(…),ExecutorService将返回一个实现Future接口的 对象(到目前为止的JDK中，返回的是FutureTask对象)。由于FutureTask实现了Runnable, 程序员也可以创建FutureTask,然后直接交给ExecutorService执行。</p>
<p>最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptlfRunning)来取消此任务的执行。</p>
<ol start="2">
<li>Executor框架的成员</li>
</ol>
<h2 id="第11章-Java并发编程实践"><a href="#第11章-Java并发编程实践" class="headerlink" title="第11章 Java并发编程实践"></a>第11章 Java并发编程实践</h2><h3 id="11-1生产者和消费者模式"><a href="#11-1生产者和消费者模式" class="headerlink" title="11.1生产者和消费者模式"></a>11.1生产者和消费者模式</h3><p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生 产线程和消费线程的工作能力来提高程序整体处理数据的速度。 </p>
<p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程 开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费 者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消 费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费 者模式。</p>
<p><strong>什么是生产者和消费者模式</strong></p>
<p>生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一 个第三者出来进行解耦，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在 学习一些设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。</p>
<h4 id="11-1-1-生产者消费者模式实战"><a href="#11-1-1-生产者消费者模式实战" class="headerlink" title="11.1.1 生产者消费者模式实战"></a>11.1.1 生产者消费者模式实战</h4><p>我和同事一起利用业余时间开发的Yuna工具中使用了生产者和消费者模式。我先介绍 下Yuna°工具，在阿里巴巴很多同事都喜欢通过邮件分享技术文章，因为通过邮件分享很方 便，大家在网上看到好的技术文章，执行复制→粘贴→发送就完成了一次分享，但是我发现 技术文章不能沉淀下来，新来的同事看不到以前分享的技术文章，大家也很难找到以前分享 过的技术文章。为了解决这个问题，我们开发了一个Yuna工具。 我们申请了一个专门用来收集分享邮件的邮箱，比如<a href="mailto:&#x73;&#104;&#x61;&#114;&#x65;&#x40;&#x61;&#108;&#105;&#98;&#x61;&#x62;&#97;&#x2e;&#x63;&#x6f;&#x6d;">&#x73;&#104;&#x61;&#114;&#x65;&#x40;&#x61;&#108;&#105;&#98;&#x61;&#x62;&#97;&#x2e;&#x63;&#x6f;&#x6d;</a>,大家将分享 的文章发送到这个邮箱，让大家每次都抄送到这个邮箱肯定很麻烦，所以我们的做法是将这 个邮箱地址放在部门邮件列表里，所以分享的同事只需要和以前一样向整个部门分享文章就 行。Yuna工具通过读取邮件服务器里该邮箱的邮件，把所有分享的邮件下载下来，包括邮 件的附件、图片和邮件回复。因为我们可能会从这个邮箱里下载到一些非分享的文章，所以 我们要求分享的邮件标题必须带有一个关键字，比如“内贸技术分享”。下载完邮件之后， 通过confluence的Web Service接口，把文章插入到confluence里，这样新同事就可以在 confluence里看以前分享过的文章了，并且Yuna工具还可以自动把文章进行分类和归档。 为了快速上线该功能，当时我们花了3天业余时间快速开发了Yuna 1.0版本。在1.0版 本中并没有使用生产者消费模式，而是使用单线程来处理，因为当时只需要处理我们一个部 门的邮件，所以单线程明显够用，整个过程是串行执行的。在一个线程里，程序先抽取全部 的邮件，转化为文章对象，然后添加全部的文章，最后删除抽取过的邮件。代码如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190335110.png" alt="image-20230617190335110"></p>
<p>Yuna工具在推广后，越来越多的部门使用这个工具，处理的时间越来越慢，Yuna是每 隔5分钟进行一次抽取的，而当邮件多的时候一次处理可能就花了几分钟，于是我在Yuna 2.0版本里使用了生产者消费者模式来处理邮件，首先生产者线程按一定的规则去邮件系统 里抽取邮件，然后存放在阻塞队列里，消费者从阻塞队列里取出文章后插入到conflunce里。 代码如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190402777.png" alt="image-20230617190402777"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190415122.png" alt="image-20230617190415122"></p>
<p>代码的执行逻辑是，生产者启动一个线程把所有邮件全部抽取到队列中，消费者启动 CPU*2个线程数处理邮件，从之前的单线程处理邮件变成了现在的多线程处理，并且抽取邮 件的线程不需要等处理邮件的线程处理完再抽取新邮件，所以使用了生产者和消费者模式 后，邮件的整体处理速度比以前要快了几倍。</p>
<h4 id="11-1-2多生产者和多消费者场景"><a href="#11-1-2多生产者和多消费者场景" class="headerlink" title="11.1.2多生产者和多消费者场景"></a>11.1.2多生产者和多消费者场景</h4><p>在多核时代，多线程并发处理速度比单 线程处理速度更快，所以可以使用多个线程 来生产数据，同样可以使用多个消费线程来 消费数据。而更复杂的情况是，消费者消费 的数据，有可能需要继续处理，于是消费者 处理完数据之后，它又要作为生产者把数据 放在新的队列里，交给其他消费者继续处理， 如图11-1所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190028401.png" alt="image-20230617190028401"></p>
<p>我们在一个长连接服务器中使用了这种 模式，生产者1负责将所有客户端发送的消息存放在阻塞队列1里，消费者1从队列里读消息，然后通过消息ID进行散列得到N个队 列中的一个，然后根据编号将消息存放在到不同的队列里，每个阻塞队列会分配一个线程来 消费阻塞队列里的数据。如果消费者2无法消费消息，就将消息再抛回到阻塞队列1中，交 给其他消费者处理。</p>
<p>以下是消息总队列的代码。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190106592.png" alt="image-20230617190106592"></p>
<p>启动一个消息分发线程。在这个线程里子队列自动去总队列里获取消息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190124219.png" alt="image-20230617190124219"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190136941.png" alt="image-20230617190136941"></p>
<p>使用散列(hash)算法获取一个子队列，代码如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190154239.png" alt="image-20230617190154239"></p>
<p>使用的时候，只需要往总队列里发消息。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617190210074.png" alt="image-20230617190210074"></p>
<h4 id="11-1-3线程池与生产消费者模式"><a href="#11-1-3线程池与生产消费者模式" class="headerlink" title="11.1.3线程池与生产消费者模式"></a>11.1.3线程池与生产消费者模式</h4><p>Java中的线程池类其实就是一种生产者和消费者模式的实现方式，但是我觉得其实现方 式更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务 数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实 现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p>
<p>我们的系统也可以使用线程池来实现多生产者和消费者模式。例如，创建N个不同规模 的Java线程池来处理不同性质的任务，比如线程池1将数据读到内存之后，交给线程池2里 的线程继续处理压缩数据。线程池1主要处理IO密集型任务，线程池2主要处理CPU密集 型任务。</p>
<p>本节讲解了生产者和消费者模式，并给出了实例。读者可以在平时的工作中思考一下哪些场景可以使用生产者消费者模式，我相信这种场景应该非常多，特别是需要处理任务时间比较长的场景，比如上传附件并处理，用户把文件上传到系统后，系统把文件丢到队列里， 然后立刻返回告诉用户上传成功，最后消费者再去队列里取出文件处理。再如，调用一个远 程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用 线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一 个接口取数据。</p>
<h3 id="11-2-线上问题定位"><a href="#11-2-线上问题定位" class="headerlink" title="11.2 线上问题定位"></a>11.2 线上问题定位</h3><p>有时候，有很多问题只有在线上或者预发环境才能发现，而线上又不能调试代码，所以 线上问题定位就只能看日志、系统状态和dump线程，本节只是简单地介绍一些常用的工具， 以帮助大家定位线上问题。</p>
<ol>
<li>在Linux命令行下使用TOP命令查看每个进程的情况，显示如下。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185600944.png" alt="image-20230617185600944"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185614756.png" alt="image-20230617185614756"></p>
<p>我们的程序是Java应用，所以只需要关注COMMAND是Java的性能数据，COMMAND 表示启动当前进程的命令，在Java进程这一行里可以看到CPU利用率是300不用担心， 这个是当前机器所有核加在一起的CPU利用率。</p>
<ol start="2">
<li>再使用top的交互命令数字1查看每个CPU的性能数据。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185642620.png" alt="image-20230617185642620"></p>
<p>命令行显示了CPU4,说明这是一个5核的虚拟机，平均每个CPU利用率在60%上。 如果这里显示CPU利用率100则很有可能程序里写了一个死循环。这些参数的含义，可 以对比表11-1来查看。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185705927.png" alt="image-20230617185705927"></p>
<ol start="3">
<li>使用top的交互命令H查看每个线程的性能信息。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185723423.png" alt="image-20230617185723423"></p>
<p>在这里可能会出现3种情况。</p>
<ul>
<li>第一种情况，某个线程CPU利用率一直100则说明是这个线程有可能有死循环， 那么请记住这个PID。 </li>
<li>第二种情况，某个线程一直在TOP10的位置，这说明这个线程可能有性能问题。 </li>
<li>第三种情况，CPU利用率高的几个线程在不停变化，说明并不是由某一个线程导致 CPU偏高。</li>
</ul>
<p>如果是第一种情况，也有可能是GC造成，可以用jstat命令看一下GC情况，看看是不 是因为持久代或年老代满了，产生FullGC,导致CPU利用率持续飙高，命令和回显如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185757002.png" alt="image-20230617185757002"></p>
<p>还可以把线程dump下来，看看究竟是哪个线程、执行什么代码造成的CPU利用率高。 执行以下命令，把线程dump到文件dump17里。执行如下命令。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185813512.png" alt="image-20230617185813512"></p>
<p>dump出来的线程ID(nid)是十六进制的，而我们用TOP命令看到的线程ID是十进制 的，所以要用printf命令转换一下进制。然后用十六进制的ID去dump里找到对应的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;x\n&quot; 31558</span><br></pre></td></tr></table></figure>

<p>输出：7b46。</p>
<h3 id="11-3性能测试"><a href="#11-3性能测试" class="headerlink" title="11.3性能测试"></a>11.3性能测试</h3><p>因为要支持某个业务，有同事向我们提出需求，希望系统的某个接口能够支持2万的 QPS,因为我们的应用部署在多台机器上，要支持两万的QPS,我们必须先要知道该接口在单机上能支持多少QPS,如果单机能支持1千QPS,我们需要20台机器才能支持2万的QPS。 需要注意的是，要支持的2万的QPS必须是峰值，而不能是平均值，比如一天当中有23个小 时QPS不足1万，只有一个小时的QPS达到了2万，我们的系统也要支持2万的QPS。</p>
<p>我们先进行性能测试。我们使用公司同事开发的性能测试工具进行测试，该工具的原理 是，用户写一个Java程序向服务器端发起请求，这个工具会启动一个线程池来调度这些任 务，可以配置同时启动多少个线程、发起请求次数和任务间隔时长。将这个程序部署在多台 机器上执行，统计出QPS和响应时长。我们在10台机器上部署了这个测试程序，每台机器 启动了100个线程进行测试，压测时长为半小时。注意不能压测线上机器，我们压测的是开 发服务器。</p>
<p>测试开始后，首先登录到服务器里查看当前有多少台机器在压测服务器，因为程序的端 口是12200,所以使用netstat命令查询有多少台机器连接到这个端口上。命令如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">§ netstat -nat I grep 12200 -c</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>通过这个命令可以知道已经有10台机器在压测服务器。QPS达到了1400,程序开始报 错获取不到数据库连接，因为我们的数据库端口是3306,用netstat命令查看已经使用了多少 个数据库连接。命令如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">§ netstat -nat I grep 3306 -c</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>增加数据库连接到20,QPS没上去，但是响应时长从平均1000毫秒下降到700毫秒， 使用TOP命令观察CPU利用率，发现已经90%了，于是升级CPU,将2核升级成4核， 和线上的机器保持一致。再进行压测，CPU利用率下去了达到了75%，PS上升到了1800。 执行一段时间后响应时长稳定在200毫秒。</p>
<p>增加应用服务器里线程池的核心线程数和最大线程数到1024,通过ps命令查看下线程 数是否增长了，执行的命令如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">§ ps -eLf I grep java -c</span><br><span class="line">1520</span><br></pre></td></tr></table></figure>

<p>再次压测，QPS并没有明显的增长，单机QPS稳定在1800左右，响应时长稳定在200 毫秒。 </p>
<p>我在性能测试之前先优化了程序的SQL语句。使用了如下命令统计执行最慢的SQL, 左边的是执行时长，单位是毫秒，右边的是执行的语句，可以看到系统执行最慢的SQL是 queryNews和queryNewlds,优化到几十毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">§grep Y /home/admin/logs/xxx/monitor/dal-rw-monitor.log lawk -F&#x27;,&#123;print §7§5)</span><br><span class="line">sort -nrlhead -20</span><br><span class="line">1811 queryNews</span><br><span class="line">1764 queryNews</span><br><span class="line">1740 queryNews</span><br><span class="line">1697 queryNews</span><br><span class="line">679 queryNewIds</span><br></pre></td></tr></table></figure>

<p><strong>性能测试中使用的其他命令</strong></p>
<ol>
<li>查看网络流量。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185427125.png" alt="image-20230617185427125"></p>
<ol start="2">
<li>查看系统平均负载。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185452468.png" alt="image-20230617185452468"></p>
<ol start="3">
<li>查看系统内存情况。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185508121.png" alt="image-20230617185508121"></p>
<ol start="4">
<li>查看CPU的利用率。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/javaconcurrent.img/image-20230617185523273.png" alt="image-20230617185523273"></p>
<h3 id="11-4异步任务池"><a href="#11-4异步任务池" class="headerlink" title="11.4异步任务池"></a>11.4异步任务池</h3><p>Java中的线程池设计得非常巧妙，可以高效并发执行多个任务，但是在某些场景下需 要对线程池进行扩展才能更好地服务于系统。例如，如果一个任务仍进线程池之后，运行线 程池的程序重启了，那么线程池里的任务就会丢失。另外，线程池只能处理本机的任务，在 集群环境下不能有效地调度所有机器的任务。所以，需要结合线程池开发一个异步任务处理池。图11-2为异步任务池设计图。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/jvm.img/image-20230617184611537.png" alt="image-20230617184611537"></p>
<p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池， 当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据中，然后某台机器 上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p>
<p>每个任务有几种状态，分别是创建(NEW)、执行中(EXECUTING)、RETRY(重试)、 挂起(SUSPEND)、中止(TEMINER)和执行完成(FINISH)。</p>
<ul>
<li>□创建：提交给任务池之后的状态。 </li>
<li>执行中：任务池从数据库中拿到任务执行时的状态。 </li>
<li>重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下 一次执行时间。 </li>
<li>挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息 后，再开始执行。 </li>
<li>中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。 </li>
<li>执行完成：任务执行结束。</li>
</ul>
<p><strong>任务池的任务隔离</strong>。异步任务有很多种类型，比如抓取网页任务、同步数据任务等，不 同类型的任务优先级不一样，但是系统资源是有限的，如果低优先级的任务非常多，高优先 级的任务就可能得不到执行，所以必须对任务进行隔离执行。使用不同的线程池处理不同的 任务，或者不同的线程池处理不同优先级的任务，如果任务类型非常少，建议用任务类型来 隔离，如果任务类型非常多，比如几十个，建议采用优先级的方式来隔离。</p>
<p><strong>任务池的重试策略。</strong>根据不同的任务类型设置不同的重试策略，有的任务对实时性要求高，那么每次的重试间隔就会非常短，如果对实时性要求不高，可以采用默认的重试策略， 重试间隔随着次数的增加，时间不断增长，比如间隔几秒、几分钟到几小时。每个任务类型 可以设置执行该任务类型线程池的最小和最大线程数、最大重试次数。</p>
<p><strong>使用任务池的注意事项。</strong>任务必须无状态：任务不能在执行任务的机器中保存数据，比如 某个任务是处理上传的文件，任务的属性里有文件的上传路径，如果文件上传到机器1,机器 2获取到了任务则会处理失败，所以上传的文件必须存在其他的集群里，比如OSS或SFTP。 </p>
<p><strong>异步任务的属性。</strong>包括任务名称、下次执行时间、已执行次数、任务类型、任务优先级 和执行时的报错信息(用于快速定位问题)。</p>
<h3 id="11-5-本章小结"><a href="#11-5-本章小结" class="headerlink" title="11.5 本章小结"></a>11.5 本章小结</h3><p>本章介绍了使用生产者和消费者模式进行并发编程、线上问题排查手段和性能测试实战，以及异步任务池的设计。并发编程的实战需要大家平时多使用和测试，才能在项目中发挥作用</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2024/12/05/Android-Studio/">Android Studio</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2024/12/05/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CStellar%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/">使用Hexo和Stellar搭建个人博客网站</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">John Doe</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1">Stellar 1.29.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-text">Java并发编程的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">第1章 并发编程的挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">1.1上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%AC%A1%E6%95%B0%E5%92%8C%E6%97%B6%E9%95%BF"><span class="toc-text">测试上下文切换次数和时长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">如何减少上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">无锁并发编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CAS%E7%AE%97%E6%B3%95"><span class="toc-text">CAS算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%91%E7%BA%BF%E7%A8%8B"><span class="toc-text">使用最少线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%AE%9E%E6%88%98"><span class="toc-text">减少上下文切换实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E6%AD%BB%E9%94%81"><span class="toc-text">1.2死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">1.3资源限制的挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">第2章 Java并发机制的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-volatile%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">2.1 volatile的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-text">2.2 synchronized的实现原理与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">2.2.1 Java对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">2.2.2锁的升级与对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2.3原子操作的实现原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">第3章 Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-text">3.1 Java内存模型的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-text">3.1.1 并发编程模型的两个关键问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-text">3.1.2 Java内存模型的抽象结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">3.1.3从源代码到指令序列的重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">3.1.4并发编程模型的分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">第4章 Java并发编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">4.1 线程简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.1.1什么是线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.1.2 为什么要使用多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">4.1.3 线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">4.1.4 线程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-Daemon%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.1.5 Daemon线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E5%90%AF%E5%8A%A8%E5%92%8C%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.2启动和终止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%9E%84%E9%80%A0%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.2.1 构造线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.2.2 启动线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E7%90%86%E8%A7%A3%E4%B8%AD%E6%96%AD"><span class="toc-text">4.2.3 理解中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E8%BF%87%E6%9C%9F%E7%9A%84suspend-%E3%80%81resume-%E5%92%8Cstop"><span class="toc-text">4.2.4 过期的suspend()、resume()和stop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E5%AE%89%E5%85%A8%E5%9C%B0%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.2.5 安全地终止线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">4.3线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-volatile%E5%92%8Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.3.1 volatile和synchronized关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">4.3.2 等待&#x2F;通知机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E7%9A%84%E7%BB%8F%E5%85%B8%E8%8C%83%E5%BC%8F"><span class="toc-text">4.3.3 等待&#x2F;通知的经典范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E7%AE%A1%E9%81%93%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">4.3.4 管道输入&#x2F;输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-Thread-join-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.3.5 Thread.join()的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.3.6 ThreadLocal的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">4.4线程应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.4.1 等待超时模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.4.2一个简单的数据库连接池示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.4.3线程池技术及其示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-text">第5章 Java中的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6"><span class="toc-text">第6章 Java并发容器和框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB-%E2%88%9A"><span class="toc-text">第7章 Java中的13个原子操作类(√)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="toc-text">7.1 原子更新基本类型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84"><span class="toc-text">7.2 原子更新数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.3 原子更新引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E7%B1%BB"><span class="toc-text">7.4 原子更新字段类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">第8章 Java中的并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E7%AD%89%E5%BE%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E7%9A%84CountDownLatch"><span class="toc-text">8.1等待多线程完成的CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9CCyclicBarrier"><span class="toc-text">8.2同步屏障CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-CyclicBarrier%E7%AE%80%E4%BB%8B"><span class="toc-text">8.2.1 CyclicBarrier简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-CyclicBarrier%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA"><span class="toc-text">8.2.2 CyclicBarrier的应用场</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-CyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.2.3 CyclicBarrier和CountDownLatch的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84Semaphore"><span class="toc-text">8.3控制并发线程数的Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9A%84Exchanger"><span class="toc-text">8.4线程间交换数据的Exchanger</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">第9章 Java中的线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">9.1线程池的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">9.2线程池的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">9.2.1线程池的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2%E5%90%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-text">9.2.2向线程池提交任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">9.2.3关闭线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4%E5%90%88%E7%90%86%E5%9C%B0%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">9.2.4合理地配置线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%9B%91%E6%8E%A7"><span class="toc-text">9.2.5线程池的监控</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-Executor%E6%A1%86%E6%9E%B6"><span class="toc-text">第10章 Executor框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-Executor%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-text">10.1 Executor框架简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%A4%E7%BA%A7%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-text">10.1.1 Executor框架的两级调度模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E6%88%90%E5%91%98"><span class="toc-text">10.1.2 Executor框架的结构与成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5"><span class="toc-text">第11章 Java并发编程实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">11.1生产者和消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98"><span class="toc-text">11.1.1 生产者消费者模式实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E5%9C%BA%E6%99%AF"><span class="toc-text">11.1.2多生产者和多消费者场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">11.1.3线程池与生产消费者模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D"><span class="toc-text">11.2 线上问题定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">11.3性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%B1%A0"><span class="toc-text">11.4异步任务池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-text">11.5 本章小结</span></a></li></ol></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>Scroll to Top</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)

    const messages = {
      light: `Switched to Light Mode`,
      dark: `Switched to Dark Mode`,
      auto: `Switched to Auto Mode`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    }
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
